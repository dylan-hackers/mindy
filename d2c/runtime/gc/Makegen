
# I've had to really work over the Windows Makefile in order to get
# the srcdir stuff to work right.  The Unix version, though, is almost
# pristine--we just added the "srcdir = $(VPATH)" and commented out a
# few lines above it.

if ($features{'compiled_for_win32'} && $features{'compiled_for_x86'}) {
    print <<'EOF';

CPU= i386
!include <ntwin32.mak>

OBJS= alloc.obj reclaim.obj allchblk.obj misc.obj mach_dep.obj os_dep.obj mark_rts.obj headers.obj mark.obj obj_map.obj blacklst.obj finalize.obj new_hblk.obj dbg_mlc.obj malloc.obj stubborn.obj dyn_load.obj typd_mlc.obj ptr_chck.obj gc_cpp.obj

all: gctest.exe cord\de.exe test_cpp.exe

EOF

    if ($features{'c_compiler_is_gcc'}) {
	print <<'EOF';
CC = gcc

CPLUSPLUSFLAGS = -O4 -finline-functions -Dtry=__try -Dexcept=__except -Dleave=__leave -Dfinally=__finally -DCRTAPI1=_cdecl -DCRTAPI2=_cdecl -D_X86_=1 -DWINVER=0x0400 -DWIN32_GCC -DWIN32 -D_WIN32 -DSILENT -DALL_INTERIOR_POINTERS -I$(SRCDIR)

CCFLAGS = $(CPLUSPLUSFLAGS) -D__STDC__

EOF
    } else {
	print <<'EOF';
CC = cl

CPLUSPLUSFLAGS = -Ox -W3 -Dtry=__try -Dexcept=__except -Dleave=__leave -Dfinally=__finally -DCRTAPI1=_cdecl -DCRTAPI2=_cdecl -nologo -D_X86_=1 -DWINVER=0x0400 -DWIN32  -D_WIN32 -DSILENT -DALL_INTERIOR_POINTERS -I$(SRCDIR)

CCFLAGS = $(CPLUSPLUSFLAGS) -D__STDC__

EOF
    }

    print <<'EOF';

alloc.obj : $(SRCDIR)/alloc.c
    $(CC) $(CCFLAGS) -c $(SRCDIR)/alloc.c -o $*.obj
reclaim.obj : $(SRCDIR)/reclaim.c
    $(CC) $(CCFLAGS) -c $(SRCDIR)/reclaim.c -o $*.obj
allchblk.obj : $(SRCDIR)/allchblk.c
    $(CC) $(CCFLAGS) -c $(SRCDIR)/allchblk.c -o $*.obj
misc.obj : $(SRCDIR)/misc.c
    $(CC) $(CCFLAGS) -c $(SRCDIR)/misc.c -o $*.obj
mach_dep.obj : $(SRCDIR)/mach_dep.c
    $(CC) $(CCFLAGS) -c $(SRCDIR)/mach_dep.c -o $*.obj
os_dep.obj : $(SRCDIR)/os_dep.c
    $(CC) $(CCFLAGS) -c $(SRCDIR)/os_dep.c -o $*.obj
mark_rts.obj : $(SRCDIR)/mark_rts.c
    $(CC) $(CCFLAGS) -c $(SRCDIR)/mark_rts.c -o $*.obj
headers.obj : $(SRCDIR)/headers.c
    $(CC) $(CCFLAGS) -c $(SRCDIR)/headers.c -o $*.obj
mark.obj : $(SRCDIR)/mark.c
    $(CC) $(CCFLAGS) -c $(SRCDIR)/mark.c -o $*.obj
obj_map.obj : $(SRCDIR)/obj_map.c
    $(CC) $(CCFLAGS) -c $(SRCDIR)/obj_map.c -o $*.obj
blacklst.obj : $(SRCDIR)/blacklst.c
    $(CC) $(CCFLAGS) -c $(SRCDIR)/blacklst.c -o $*.obj
finalize.obj : $(SRCDIR)/finalize.c
    $(CC) $(CCFLAGS) -c $(SRCDIR)/finalize.c -o $*.obj
new_hblk.obj : $(SRCDIR)/new_hblk.c
    $(CC) $(CCFLAGS) -c $(SRCDIR)/new_hblk.c -o $*.obj
dbg_mlc.obj : $(SRCDIR)/dbg_mlc.c
    $(CC) $(CCFLAGS) -c $(SRCDIR)/dbg_mlc.c -o $*.obj
malloc.obj : $(SRCDIR)/malloc.c
    $(CC) $(CCFLAGS) -c $(SRCDIR)/malloc.c -o $*.obj
stubborn.obj : $(SRCDIR)/stubborn.c
    $(CC) $(CCFLAGS) -c $(SRCDIR)/stubborn.c -o $*.obj
dyn_load.obj : $(SRCDIR)/dyn_load.c
    $(CC) $(CCFLAGS) -c $(SRCDIR)/dyn_load.c -o $*.obj
typd_mlc.obj : $(SRCDIR)/typd_mlc.c
    $(CC) $(CCFLAGS) -c $(SRCDIR)/typd_mlc.c -o $*.obj
ptr_chck.obj : $(SRCDIR)/ptr_chck.c
    $(CC) $(CCFLAGS) -c $(SRCDIR)/ptr_chck.c -o $*.obj

# source is NOT in srcdir, but here, because we copied it here
gc_cpp.obj : gc_cpp.cpp
    $(CC) $(CPLUSPLUSFLAGS) -c gc_cpp.cpp -o $*.obj


#.c.obj:
#	$(cc) $(cdebug) $(cflags) $(cvars) -DSILENT -DALL_INTERIOR_POINTERS -D__STDC__ $*.c /Fo$*.obj

#.cpp.obj:
#	$(cc) $(cdebug) $(cflags) $(cvars) -DSILENT -DALL_INTERIOR_POINTERS $*.CPP /Fo$*.obj

$(OBJS) test.obj: $(SRCDIR)/gc_priv.h $(SRCDIR)/gc_hdrs.h $(SRCDIR)/gc.h

gc.lib: $(OBJS)
	lib /MACHINE:i386 /out:gc.lib $(OBJS)
# The original NT SDK used lib32 instead of lib

gctest.exe: test.obj gc.lib
#	The following works for win32 debugging.  For win32s debugging use debugtype:coff
#	and add mapsympe line.
#  This produces a "GUI" applications that opens no windows and writes to the log file
#  "gc.log".  This is done to make the result runnable under win32s.
	$(link) -debug:full -debugtype:cv $(guiflags) -stack:131072 -out:$*.exe test.obj $(guilibs) gc.lib
#	mapsympe -n -o gctest.sym gctest.exe

cord\de_win.rbj: cord\de_win.res
	cvtres -$(CPU) cord\de_win.res -o cord\de_win.rbj

cord\de.obj cord\de_win.obj: cord\cord.h cord\private\cord_pos.h cord\de_win.h cord\de_cmds.h

cord\de_win.res: cord\de_win.rc cord\de_win.h cord\de_cmds.h
	$(rc) $(rcvars) -r -fo cord\de_win.res $(cvars) cord\de_win.rc

# Cord/de is a real win32 gui application.
cord\de.exe: cord\cordbscs.obj cord\cordxtra.obj cord\de.obj cord\de_win.obj cord\de_win.rbj gc.lib
	$(link) -debug:full -debugtype:cv $(guiflags) -stack:16384 -out:cord\de.exe  cord\cordbscs.obj cord\cordxtra.obj cord\de.obj cord\de_win.obj cord\de_win.rbj gc.lib $(guilibs)

gc_cpp.obj: $(SRCDIR)/gc_cpp.h $(SRCDIR)/gc.h

gc_cpp.cpp: $(SRCDIR)/gc_cpp.cc
	cp -f $(SRCDIR)/gc_cpp.cc gc_cpp.cpp

test_cpp.cpp: test_cpp.cc
	copy test_cpp.cc test_cpp.cpp

# This generates the C++ test executable.  The executable expects
# a single numeric argument, which is the number of iterations.
# The output appears in the file "gc.log".
test_cpp.exe: test_cpp.obj gc_cpp.h gc.h gc.lib
	$(link) -debug:full -debugtype:cv $(guiflags) -stack:16384 -out:test_cpp.exe test_cpp.obj gc.lib $(guilibs)

EOF

    push(@compile_dependencies, 'gc.lib');
    do install($libdir, 'gc.lib');

    push(@files_to_clean, '$(OBJS)', 'gc.lib', 'gctest', 'gctest_dyn_link',
	 'test_cpp', 'setjmp_test', 'mon.out', 'gmon.out', 'a.out', 'core',
	 'if_not_there', 'if_mach', '$(CORD_OBJS)', 'cord/cordtest', 
	 'cord/de');


} elsif ($features{'compiled_for_unix'}) {

    print <<"EOF";

# Primary targets:
# libgc.a - builds basic library
# c++ - adds C++ interface to library
# cords - adds cords (heavyweight strings) to library
# test - prints porting information, then builds basic version of libgc.a,
#      	 and runs some tests of collector and cords.  Does not add cords or
#	 c++ interface to libgc.a
# cord/de - builds dumb editor based on cords.
CC=$CC
CXX=g++ -ansi
# Needed only for "make c++", which adds the c++ interface
AS=as
CFLAGS= -O -DNO_SIGNALS -DSILENT
EOF

    print <<'EOF';
# Setjmp_test may yield overly optimistic results when compiled
# without optimization.
# -DSILENT disables statistics printing, and improves performance.
# -DCHECKSUMS reports on erroneously clear dirty bits, and unexpectedly
#   altered stubborn objects, at substantial performance cost.
#   Use only for incremental collector debugging.
# -DFIND_LEAK causes the collector to assume that all inaccessible
#   objects should have been explicitly deallocated, and reports exceptions.
#   Finalization and the test program are not usable in this mode.
# -DSOLARIS_THREADS enables support for Solaris (thr_) threads.
#   (Clients should also define SOLARIS_THREADS and then include
#   gc.h before performing thr_ or dl* or GC_ operations.)
#   This is broken on nonSPARC machines.
# -DALL_INTERIOR_POINTERS allows all pointers to the interior
#   of objects to be recognized.  (See gc_priv.h for consequences.)
# -DSMALL_CONFIG tries to tune the collector for small heap sizes,
#   usually causing it to use less space in such situations.
#   Incremental collection no longer works in this case.
# -DLARGE_CONFIG tunes the collector for unusually large heaps.
#   Necessary for heaps larger than about 500 MB on most machines.
#   Recommended for heaps larger than about 64 MB.
# -DDONT_ADD_BYTE_AT_END is meaningful only with
#   -DALL_INTERIOR_POINTERS.  Normally -DALL_INTERIOR_POINTERS
#   causes all objects to be padded so that pointers just past the end of
#   an object can be recognized.  This can be expensive.  (The padding
#   is normally more than one byte due to alignment constraints.)
#   -DDONT_ADD_BYTE_AT_END disables the padding.
# -DNO_SIGNALS does not disable signals during critical parts of
#   the GC process.  This is no less correct than many malloc 
#   implementations, and it sometimes has a significant performance
#   impact.  However, it is dangerous for many not-quite-ANSI C
#   programs that call things like printf in asynchronous signal handlers.
# -DOPERATOR_NEW_ARRAY declares that the C++ compiler supports the
#   new syntax "operator new[]" for allocating and deleting arrays.
#   See gc_cpp.h for details.  No effect on the C part of the collector.
#   This is defined implicitly in a few environments.
# -DREDIRECT_MALLOC=X causes malloc, realloc, and free to be defined
#   as aliases for X, GC_realloc, and GC_free, respectively.
#   Calloc is redefined in terms of the new malloc.  X should
#   be either GC_malloc or GC_malloc_uncollectable.
#   The former is occasionally useful for working around leaks in code
#   you don't want to (or can't) look at.  It may not work for
#   existing code, but it often does.  Neither works on all platforms,
#   since some ports use malloc or calloc to obtain system memory.
#   (Probably works for UNIX, and win32.)
# -DNO_DEBUG removes GC_dump and the debugging routines it calls.
#   Reduces code size slightly at the expense of debuggability.

CXXFLAGS= $(CFLAGS)
AR= ar
RANLIB= ranlib


# Redefining srcdir allows object code for the nonPCR version of the collector
# to be generated in different directories.  In this case, the destination directory
# should contain a copy of the original include directory.
# srcdir = .
# VPATH = $(srcdir)
# 
srcdir = $(VPATH)


OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o typd_mlc.o ptr_chck.o

CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c typd_mlc.c ptr_chck.c

CORD_SRCS=  cord/cordbscs.c cord/cordxtra.c cord/cordprnt.c cord/de.c cord/cordtest.c cord/cord.h cord/ec.h cord/cord_pos.h cord/de_win.c cord/de_win.h cord/de_cmds.h cord/de_win.ICO cord/de_win.RC cord/SCOPTIONS.amiga cord/SMakefile.amiga

CORD_OBJS=  cord/cordbscs.o cord/cordxtra.o cord/cordprnt.o

SRCS= $(CSRCS) mips_mach_dep.s rs6000_mach_dep.s alpha_mach_dep.s sparc_mach_dep.s gc.h gc_typed.h gc_hdrs.h gc_priv.h gc_private.h config.h gc_mark.h include/gc_inl.h include/gc_inline.h gc.man if_mach.c if_not_there.c gc_cpp.cc gc_cpp.h $(CORD_SRCS)

OTHER_FILES= Makefile PCR-Makefile OS2_MAKEFILE NT_MAKEFILE BCC_MAKEFILE \
           README test.c test_cpp.cc setjmp_t.c SMakefile.amiga \
           SCoptions.amiga README.amiga README.win32 cord/README \
           cord/gc.h include/gc.h include/gc_typed.h include/cord.h \
           include/ec.h include/private/cord_pos.h include/gc_c++.h \
           README.QUICK callprocs pc_excludes barrett_diagram \
           README.OS2 README.Mac MacProjects.sit.hqx MacOS.c \
           EMX_MAKEFILE makefile.depend README.debugging \
           include/gc_cpp.h Mac_files/datastart.c Mac_files/dataend.c \
           Mac_files/MacOS_config.h Mac_files/MacOS_Test_config.h

CORD_INCLUDE_FILES= $(srcdir)/gc.h $(srcdir)/cord/cord.h $(srcdir)/cord/ec.h \
           $(srcdir)/cord/cord_pos.h

# Libraries needed for curses applications.  Only needed for de.
CURSES= -lcurses -ltermlib

# The following is irrelevant on most systems.  But a few
# versions of make otherwise fork the shell specified in
# the SHELL environment variable.
SHELL= /bin/sh

SPECIALCFLAGS = 
# Alternative flags to the C compiler for mach_dep.c.
# Mach_dep.c often doesn't like optimization, and it's
# not time-critical anyway.
# Set SPECIALCFLAGS to -q nodirect_code on Encore.

ALPHACFLAGS = -non_shared
# Extra flags for linking compilation on DEC Alpha

all: libgc.a gctest

pcr: PCR-Makefile gc_private.h gc_hdrs.h gc.h config.h mach_dep.o $(SRCS)
	make -f PCR-Makefile depend
	make -f PCR-Makefile

$(OBJS) test.o dyn_load.o dyn_load_sunos53.o: $(srcdir)/gc_priv.h $(srcdir)/gc_hdrs.h $(srcdir)/gc.h \
    $(srcdir)/config.h $(srcdir)/gc_typed.h Makegen
# The dependency on Makefile is needed.  Changing
# options such as -DSILENT affects the size of GC_arrays,
# invalidating all .o files that rely on gc_priv.h

mark.o typd_mlc.o finalize.o: $(srcdir)/gc_mark.h

EOF

print "libgc$dot_lib: \$(OBJS) dyn_load.o\n";
    print <<'EOF';
	rm -f on_sparc_sunos5
	./if_mach SPARC SUNOS5 touch on_sparc_sunos5
	./if_mach SPARC SUNOS5 $(AR) rus libgc.a $(OBJS) dyn_load.o
EOF
print "\t./if_not_there on_sparc_sunos5 \$(AR) rus libgc$dot_lib \$(OBJS) dyn_load.o\n";
    print <<'EOF';
	./if_not_there on_sparc_sunos5 $(RANLIB) libgc.a || cat /dev/null
#	ignore ranlib failure; that usually means it doesn't exist, and isn't needed

cords: $(CORD_OBJS) cord/cordtest
	rm -f on_sparc_sunos5
	./if_mach SPARC SUNOS5 touch on_sparc_sunos5
	./if_mach SPARC SUNOS5 $(AR) rus libgc.a $(CORD_OBJS)
	./if_not_there on_sparc_sunos5 $(AR) ru libgc.a $(CORD_OBJS)
	./if_not_there on_sparc_sunos5 $(RANLIB) libgc.a || cat /dev/null

gc_cpp.o: $(srcdir)/gc_cpp.cc $(srcdir)/gc_cpp.h $(srcdir)/gc.h Makegen
	$(CXX) -c $(CXXFLAGS) $(srcdir)/gc_cpp.cc

test_cpp: $(srcdir)/test_cpp.cc $(srcdir)/gc_cpp.h gc_cpp.o $(srcdir)/gc.h libgc.a
	$(CXX) $(CXXFLAGS) -o test_cpp $(srcdir)/test_cpp.cc gc_cpp.o libgc.a

c++: gc_cpp.o $(srcdir)/gc_cpp.h test_cpp
	rm -f on_sparc_sunos5
	./if_mach SPARC SUNOS5 touch on_sparc_sunos5
	./if_mach SPARC SUNOS5 $(AR) rus libgc.a gc_cpp.o
	./if_not_there on_sparc_sunos5 $(AR) ru libgc.a gc_cpp.o
	./if_not_there on_sparc_sunos5 $(RANLIB) libgc.a || cat /dev/null
	./test_cpp 1

dyn_load_sunos53.o: dyn_load.c
	$(CC) $(CFLAGS) -DSUNOS53_SHARED_LIB -c dyn_load.c -o $@

# SunOS5 shared library version of the collector
libgc.so: $(OBJS) dyn_load_sunos53.o
	$(CC) -G -o libgc.so $(OBJS) dyn_load_sunos53.o -ldl

# Alpha/OSF shared library version of the collector
libalphagc.so: $(OBJS)
	ld -shared -o libalphagc.so $(OBJS) dyn_load.o -lc

mach_dep.o: $(srcdir)/mach_dep.c $(srcdir)/mips_mach_dep.s $(srcdir)/rs6000_mach_dep.s if_mach if_not_there
	rm -f mach_dep.o
	./if_mach MIPS "" $(AS) -o mach_dep.o $(srcdir)/mips_mach_dep.s
#  The above doesn't work with gas, which doesn't run cpp.
#  Rename the above file to end in .S, and then use
#  gcc -c -o mach_dep.o mips_mach_dep.S instead.
	./if_mach RS6000 "" $(AS) -o mach_dep.o $(srcdir)/rs6000_mach_dep.s
	./if_mach ALPHA "" $(AS) -o mach_dep.o $(srcdir)/alpha_mach_dep.s
	./if_mach SPARC SUNOS5 $(AS) -o mach_dep.o $(srcdir)/sparc_mach_dep.s
	./if_not_there mach_dep.o $(CC) -c $(SPECIALCFLAGS) $(srcdir)/mach_dep.c

mark_rts.o: $(srcdir)/mark_rts.c if_mach if_not_there
	rm -f mark_rts.o
	./if_mach ALPHA "" $(CC) -c $(CFLAGS) -Wo,-notail $(srcdir)/mark_rts.c
	./if_not_there mark_rts.o $(CC) -c $(CFLAGS) $(srcdir)/mark_rts.c
#	work-around for DEC optimizer tail recursion elimination bug

cord/cordbscs.o: $(srcdir)/cord/cordbscs.c $(CORD_INCLUDE_FILES)
	$(CC) $(CFLAGS) -c $(srcdir)/cord/cordbscs.c
	mv cordbscs.o cord/cordbscs.o
#  not all compilers understand -o filename

cord/cordxtra.o: $(srcdir)/cord/cordxtra.c $(CORD_INCLUDE_FILES)
	$(CC) $(CFLAGS) -c $(srcdir)/cord/cordxtra.c
	mv cordxtra.o cord/cordxtra.o

cord/cordprnt.o: $(srcdir)/cord/cordprnt.c $(CORD_INCLUDE_FILES)
	$(CC) $(CFLAGS) -c $(srcdir)/cord/cordprnt.c
	mv cordprnt.o cord/cordprnt.o

cord/cordtest: $(srcdir)/cord/cordtest.c $(CORD_OBJS) libgc.a
	rm -f cord/cordtest
	./if_mach SPARC SUNOS5 $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) libgc.a -lthread -ldl
	./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) libgc.a -lucb
	./if_not_there cord/cordtest $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) libgc.a

cord/de: $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o libgc.a
	rm -f cord/de
	./if_mach SPARC SUNOS5 $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o libgc.a $(CURSES) -lthread -ldl
	./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o libgc.a $(CURSES) -lucb
	./if_mach RS6000 "" $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o libgc.a -lcurses
	./if_mach I386 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o libgc.a -lcurses
	./if_not_there cord/de $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o libgc.a $(CURSES)

if_mach: $(srcdir)/if_mach.c $(srcdir)/config.h
	$(CC) $(CFLAGS) -o if_mach $(srcdir)/if_mach.c

if_not_there: $(srcdir)/if_not_there.c
	$(CC) $(CFLAGS) -o if_not_there $(srcdir)/if_not_there.c

#clean: 
#	rm -f libgc.a *.o gctest gctest_dyn_link test_cpp \
#	      setjmp_test  mon.out gmon.out a.out core if_not_there if_mach \
#	      $(CORD_OBJS) cord/cordtest cord/de
#	-rm -f *~

gctest: test.o libgc.a if_mach if_not_there
	rm -f gctest
	./if_mach SPARC SUNOS5 $(CC) $(CFLAGS) -o gctest  test.o libgc.a -lthread -ldl
	./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o gctest  test.o libgc.a -lucb
	./if_not_there gctest $(CC) $(CFLAGS) -o gctest test.o libgc.a

# If an optimized setjmp_test generates a segmentation fault,
# odds are your compiler is broken.  Gctest may still work.
# Try compiling setjmp_t.c unoptimized.
setjmp_test: $(srcdir)/setjmp_t.c $(srcdir)/gc.h if_mach if_not_there
	$(CC) $(CFLAGS) -o setjmp_test $(srcdir)/setjmp_t.c

test:  KandRtest cord/cordtest
	cord/cordtest

# Those tests that work even with a K&R C compiler:
KandRtest: setjmp_test gctest
	./setjmp_test
	./gctest

gc.tar: $(SRCS) $(OTHER_FILES)
	tar cvf gc.tar $(SRCS) $(OTHER_FILES)

pc_gc.tar: $(SRCS) $(OTHER_FILES)
	tar cvfX pc_gc.tar pc_excludes $(SRCS) $(OTHER_FILES)

floppy: pc_gc.tar
	-mmd a:/cord
	-mmd a:/include
	mkdir /tmp/pc_gc
	cat pc_gc.tar | (cd /tmp/pc_gc; tar xvf -)
	-mcopy -tmn /tmp/pc_gc/* a:
	-mcopy -tmn /tmp/pc_gc/cord/* a:/cord
	-mcopy -mn /tmp/pc_gc/cord/de_win.ICO a:/cord
	-mcopy -tmn /tmp/pc_gc/include/* a:/cord
	rm -r /tmp/pc_gc

gc.tar.Z: gc.tar
	compress gc.tar

lint: $(CSRCS) test.c
	lint -DLINT $(CSRCS) test.c | egrep -v "possible pointer alignment problem|abort|exit|sbrk|mprotect|syscall"

# BTL: added to test shared library version of collector.
# Currently works only under SunOS5.  Requires GC_INIT call from statically
# loaded client code.
ABSDIR = `pwd`
gctest_dyn_link: test.o libgc.so
	$(CC) -L$(ABSDIR) -R$(ABSDIR) -o gctest_dyn_link test.o -lgc -ldl -lthread


EOF
    push(@compile_dependencies, "libgc$dot_lib");

    do install($libdir, "libgc$dot_lib");

    push(@files_to_clean, '$(OBJS)', "libgc$dot_lib", 'gctest',
	 'gctest_dyn_link', 
	 'test_cpp', 'setjmp_test', 'mon.out', 'gmon.out', 'a.out', 'core',
	 'if_not_there', 'if_mach', '$(CORD_OBJS)', 'cord/cordtest', 
	 'cord/de');
} else {
    &unknown_platform_error();
}




