$COPTS = "-DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DALL_INTERIOR_POINTERS "
    . "-DNO_EXECUTE_PERMISSION -DSILENT -DLARGE_CONFIG -Iinclude";

$inc = "include/";
$priv = "include/private/";

@std_deps = ($inc.'gc.h', $priv.'gc_priv.h', $priv.'gcconfig.h', $priv.'gc_hdrs.h');

&emit_c_file_rule('allchblk', @std_deps);
&emit_c_file_rule('alloc', @std_deps, 'version.h');
&emit_c_file_rule('blacklst', @std_deps);
&emit_c_file_rule('checksums', @std_deps);
&emit_c_file_rule('dbg_mlc', @std_deps);

&emit_c_file_rule('dyn_load', @std_deps);

&emit_c_file_rule('finalize', @std_deps, $priv.'gc_mark.h');
&emit_c_file_rule('headers', @std_deps);
&emit_c_file_rule('linux_threads', @std_deps);

# FIXME
if ($target_name =~ /^sparc.*-solaris/) {
    &emit_asm_file_rule('mach_dep', 'sparc_mach_dep');
} elsif ($target_name =~ /^sparc.*-openbsd/) {
    &emit_asm_file_rule('mach_dep', 'sparc_sunos4_mach_dep');
} elsif ($target_name =~ /^sparc.*-sunos4/) {
    &emit_asm_file_rule('mach_dep', 'sparc_sunos4_mach_dep');
} elsif ($target_name =~ /^alpha/) {
    &emit_cppasm_file_rule('mach_dep', 'alpha_mach_dep');
} elsif ($target_name =~ /^mips-irix/) {
    &emit_asm_file_rule('mach_dep', 'mips_sgi_mach_dep');
} elsif ($target_name =~ /^mips-riscos/) {
    &emit_asm_file_rule('mach_dep', 'mips_ultrix_mach_dep');
} elsif ($target_name =~ /^mips-ultrix/) {
    &emit_asm_file_rule('mach_dep', 'mips_ultrix_mach_dep');
} elsif ($target_name =~ /rs6000/) {
    &emit_asm_file_rule('mach_dep', 'rs6000_mach_dep');
} else {
    local ($CFLAGS) = "-g";
    &emit_c_file_rule('mach_dep', @std_deps);
}

&emit_c_file_rule('malloc', @std_deps);
&emit_c_file_rule('mallocx', @std_deps);
&emit_c_file_rule('mark', @std_deps, $priv.'gc_mark.h');
if ($target_name =~ /^alpha/) {
    local ($CFLAGS) = "$CFLAGS -Wo,-notail";
    &emit_c_file_rule('mark_rts', @std_deps);
} else {
    &emit_c_file_rule('mark_rts', @std_deps);
}

&emit_c_file_rule('irix_threads', @std_deps);
&emit_c_file_rule('solaris_pthreads', @std_deps, $priv.'solaris_threads.h');
&emit_c_file_rule('solaris_threads', @std_deps, 'solaris_threads.c');

&emit_c_file_rule('misc', @std_deps);
&emit_c_file_rule('new_hblk', @std_deps);
&emit_c_file_rule('obj_map', @std_deps);
&emit_c_file_rule('os_dep', @std_deps);
&emit_c_file_rule('ptr_chck', @std_deps, $priv.'gc_mark.h');
&emit_c_file_rule('reclaim', @std_deps);
&emit_c_file_rule('stubborn', @std_deps);
&emit_c_file_rule('typd_mlc', @std_deps, $priv.'gc_mark.h', $inc.'gc_typed.h');

$lib_name = "$lib_prefix" . "gc$dot_lib";

$objs =
    "allchblk$dot_obj"
    . " alloc$dot_obj"
    . " blacklst$dot_obj"
    . " checksums$dot_obj"
    . " dbg_mlc$dot_obj"
    . " dyn_load$dot_obj"
    . " finalize$dot_obj"
    . " headers$dot_obj"
    . " irix_threads$dot_obj"
    . " linux_threads$dot_obj"
    . " mach_dep$dot_obj"
    . " malloc$dot_obj"
    . " mallocx$dot_obj"
    . " mark$dot_obj"
    . " mark_rts$dot_obj"
    . " misc$dot_obj"
    . " new_hblk$dot_obj"
    . " obj_map$dot_obj"
    . " os_dep$dot_obj"
    . " ptr_chck$dot_obj"
    . " reclaim$dot_obj"
    . " solaris_pthreads$dot_obj"
    . " solaris_threads$dot_obj"
    . " stubborn$dot_obj"
    . " typd_mlc$dot_obj";

print "$lib_name: $objs\n";
print "\trm -f $lib_name\n\t";

if($target_name =~ /^ppc/) {
    $target_platform{'link_shared_library_command'} = $target_platform{'link_shared_library_command'} . " -static";
}

if ($shared) {
    printf($target_platform{'link_shared_library_command'}, $lib_name,
     $objs, $libdir);
    print "\n";
    if ($static) {
	local ($dot_lib)
	    = split(/\s+/, $target_platform{'library_filename_suffix'});
	local ($unit_prefix) = "gc";
	print "\trm -f $lib_prefix$unit_prefix$dot_lib\n";
	print "\tln -s .libs/$lib_prefix$unit_prefix$dot_lib",
	" $lib_prefix$unit_prefix$dot_lib\n";
    }
} else {
    printf($target_platform{'link_library_command'}, $lib_name, $objs);
    print "\n";
    if($target_platform{'randomize_library_command'}) {
	print "\t";
        printf($target_platform{'randomize_library_command'}, $lib_name);
        print "\n";
    }
}

push(@compile_dependencies, $lib_name);
do install_library($libdir, $lib_name, $shared);
push(@files_to_clean, $lib_name);
