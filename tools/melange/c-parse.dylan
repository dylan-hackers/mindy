module: c-parse
author:  Robert Stockton (rgs@cs.cmu.edu)
copyright: Copyright (C) 1994, Carnegie Mellon University
	   All rights reserved.
	   This code was produced by the Gwydion Project at Carnegie Mellon
	   University.  If you are interested in using this code, contact
	   "Scott.Fahlman@cs.cmu.edu" (Internet).
rcs-header: $Header: /scm/cvs/src/tools/melange/Attic/c-parse.dylan,v 1.1 1998/05/03 19:55:53 andreas Exp $

//======================================================================
//
// Copyright (c) 1994  Carnegie Mellon University
// All rights reserved.
//
//======================================================================

//======================================================================
// Module c-parse handles parsing of native C header files.  Theoretically, we
// could have arbitrary C code in these files.  However, in practice we only
// need to be able to parse about half of the C language.
//
// The actual "source" for the c parser is contained in "c-parse.input", which
// is an input file for a lisp-based Dylan parser generator.  (This is a
// logical route to follow for bootstrapping purposes.  It would clearly be
// useful to re-implement the generator in Dylan at some future date.)
// "C-parse.dylan" is the pure Dylan output of this generator, and should
// *not* be considered human readable code.
//
// The "parse-tree" is a very ad-hoc structure, because it is intended to be
// quite ephemeral.  The final goal is to add an ordered sequence of
// <declaration>s to the <parse-state> which both controls the parsing process
// and returns the results of the parse.  This approach allows us to do a
// single pass parse of the data, and also support the feedback required to
// handle C's "type names", which are context sensitive.
//
// The token stream provided by the tokenizer may actually correspond to
// several different "included" files.  We can detect transitions into and out
// of recursively included files by watching for <begin-include-token> and
// <end-include-token>.  We make the simplifying assumption that declarations
// will not be split across include files.  This assumption should be
// justifiable on the basis that any exception would be unbearably ugly.
//
// The raw parse engine has been fitted with a number of different front ends
// to allow several different types of data to be parsed.  The following
// functions are exported:
//   parse(filename, #key defines, undefines) => result :: <parse-file-state>
//     This function processes an entire include file, leaving a series of
//     declarations in the returned parse state.
//   parse-type(alien-name :: <string>, old-state :: <parse-file-state>)
//   => result :: <declaration>
//     This function parses the contents of the given string and tries to
//     interpret it as the name of an object or type declared in "old-state".
//     Parse-type will signal an error if no such declaration is found.
//   parse-macro(cpp-name :: <string>, old-state :: <parse-file-state>)
//   => result :: constant-value or <declaration>
//     This function tries to evaluate a preprocessor constant in hopes that
//     it will either evaluate to a type or object name or to a constant
//     compile time value.  It returns the matched declaration or value, or it
//     signals an error. 
//   cpp-parse(tokenizer :: <tokenizer>) => result :: <integer>
//     This function evaluates a line of CPP input according to a limited set
//     of C operators and an odd set of evaluation rules which make undefined
//     identifiers into integers.  (Note that this function is used by the
//     tokenizer, but also recursively uses the tokenizer by specifying a few
//     magic keywords to avoid infinite recursion.)  This function consumes
//     one line's worth of tokens from the tokenizer and then leaves it in a
//     consistent state for further processing by a different parser.
//
// The input file is messier than it might be, because we have retained
// productions corresponding to the entire C language -- simply commenting out
// the ones which are not needed for header files.  This should simplify
// future expansion.
//======================================================================

//----------------------------------------------------------------------
// Simple parser support 
//----------------------------------------------------------------------

// *HACK*: We temporarily use a global variable to figure out whether a given
// declaration is an object declaration or a typedef declaration.  This
// appears to be simpler than trying to propogate detailed information
// upwards.
//
define variable *typedef-flag* = #f;

// This function checks to see whether the given object can be interpreted as
// an integer.  If so, it returns the integer value.  Otherwise, it raises an
// error.  This function is used to evaluate compile time constants.
//
define generic int-value (value :: <object>, state :: <parse-state>);

define method int-value (value :: <integer>, state :: <parse-state>)
  value;
end method;

define method int-value (value :: <token>, state :: <parse-state>)
  parse-error(value, "Value in constant expression must be an integer.");
end method;

define method int-value (token :: <integer-token>, state :: <parse-state>)
  token.value;
end method;

define method int-value (value :: <object>, state :: <parse-state>)
  error(value, "Value in constant expression must be an integer.");
end method;

// This method will only be called if we are evaluating an expression in a CPP
// line.  It is not called for arbitrary identifiers.
//
define method int-value
    (value :: <identifier-token>, state :: <parse-cpp-state>)
  let expansion = element(value.generator.cpp-table,
                          value.string-value, default: #f);
  case
    expansion == #f => 
      // The C preprocessor blithely accepts undefined identifiers as "0"
      0;
    empty?(expansion) =>
      1;
    expansion.size > 1 =>
      int-value(parse-macro(value.string-value, state), state);
    otherwise =>
      int-value(head(expansion), state);
  end case;
end method;

// Evaluate identifiers in the case where we are *not* evaluating an
// expression in a CPP line.
//
define method int-value
    (value :: <identifier-token>, state :: <parse-state>)
  let object-decl = element(state.objects, value.string-value, default: #f);
  if (instance?(object-decl, <enum-slot-declaration>))
    object-decl.constant-value;
  else
    parse-error(value, "Value in constant expression must be an integer.");
  end if;
end method int-value;

define constant <source-location> = false-or(<parse-state>);


//----------------------------------------------------------------------
// The actual productions.  The format is
//  production (sub-production-or-<token> .....)
//    Arbitrary dylan code -- variables %1 - %n correspond to the
//    sub-productions, and @0 is a <parse-state> which is passed into each
//    action routine for record-keeping purposes.
//  %
//----------------------------------------------------------------------

define constant $action-bits = 2;
define constant $action-mask = ash(1, $action-bits) - 1;

define constant $error-action = 0;
define constant $accept-action = 1;
define constant $reduce-action = 2;
define constant $shift-action = 3;

define constant $action-table
  = #[#[7, 0, 11, 15, 0, 139, 0, 0, 0, 0, 35, 23, 147, 147, 147, 147, 147, 147, 147, 147, 147, 19, 855, 0, 0, 0, 0, 39, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 927, 947, 967, 0],
      #[6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[578, 0, 578, 578, 0, 578, 0, 0, 0, 0, 578, 578, 578, 578, 578, 578, 578, 578, 578, 578, 578, 578, 578, 0, 0, 0, 0, 578, 578, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[582, 0, 582, 582, 0, 582, 0, 0, 0, 0, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 0, 0, 0, 0, 582, 582, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 139, 0, 0, 0, 0, 35, 23, 147, 147, 147, 147, 147, 147, 147, 147, 147, 0, 27, 0, 0, 0, 0, 39, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 314, 0, 0, 0, 0, 314, 314, 314, 314, 314, 314, 314, 314, 314, 314, 314, 0, 314, 0, 0, 0, 0, 314, 314, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 318, 0, 0, 0, 0, 318, 318, 318, 318, 318, 318, 318, 318, 318, 318, 318, 0, 318, 0, 0, 0, 0, 318, 318, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 139, 0, 0, 0, 0, 35, 23, 147, 147, 147, 147, 147, 147, 147, 147, 147, 0, 27, 0, 0, 0, 0, 39, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 354, 354, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 354, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 358, 358, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 358, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 751, 751, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 139, 0, 0, 0, 0, 35, 0, 147, 147, 147, 147, 147, 147, 147, 147, 147, 0, 0, 0, 0, 0, 0, 39, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[330, 0, 0, 0, 330, 330, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 330, 330, 0, 330, 330, 330, 0, 0, 330, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 679, 679, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[590, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 590, 590, 0, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 0, 0, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 0, 590, 590, 590, 590, 590, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 422, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 0, 422, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 42, 0, 42, 42, 0, 42, 42, 42, 42, 42, 42, 42, 42, 42, 0, 0, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 0, 42, 42, 0, 0, 42, 0, 0, 0, 0],
      #[46, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 46, 46, 0, 46, 46, 0, 46, 46, 46, 46, 46, 46, 46, 46, 46, 0, 0, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 0, 46, 46, 0, 0, 46, 0, 0, 0, 0],
      #[54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 54, 54, 0, 54, 54, 0, 54, 54, 54, 54, 54, 54, 54, 54, 54, 0, 0, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 0, 54, 54, 0, 0, 54, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 91, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[62, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 62, 0, 62, 62, 0, 62, 62, 62, 62, 62, 62, 62, 62, 62, 0, 0, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 0, 62, 62, 0, 0, 62, 0, 0, 0, 0],
      #[70, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 70, 70, 0, 107, 70, 0, 70, 70, 70, 70, 70, 70, 70, 70, 70, 0, 0, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 0, 70, 70, 0, 0, 70, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[0, 0, 0, 0, 82, 0, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 82, 0, 0, 0, 0, 0, 0, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 82, 82, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 82],
      #[0, 0, 0, 0, 86, 0, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 0, 0, 0, 0, 0, 0, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86],
      #[0, 0, 0, 0, 90, 0, 90, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90, 0, 0, 0, 0, 0, 0, 90, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90, 90, 90, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 139, 0, 0, 0, 0, 35, 0, 147, 147, 147, 147, 147, 147, 147, 147, 147, 0, 0, 0, 0, 0, 0, 39, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[334, 0, 0, 0, 334, 334, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 334, 334, 0, 334, 334, 334, 0, 0, 334, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[338, 0, 0, 0, 338, 338, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 338, 338, 0, 338, 338, 338, 0, 0, 338, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[474, 0, 0, 0, 474, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 474, 474, 0, 474, 474, 474, 0, 0, 474, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[322, 0, 0, 0, 322, 322, 0, 0, 0, 0, 0, 0, 147, 147, 147, 147, 147, 147, 147, 147, 147, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 322, 322, 0, 322, 322, 322, 0, 0, 322, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[326, 0, 0, 0, 326, 326, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 326, 326, 0, 326, 326, 326, 0, 0, 326, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[478, 0, 0, 0, 478, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 478, 478, 0, 478, 478, 478, 0, 0, 478, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[522, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 522, 0, 423, 522, 163, 0, 0, 567, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 167, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[546, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 546, 0, 546, 546, 546, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[94, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 94, 94, 0, 0, 94, 0, 94, 94, 94, 94, 94, 94, 94, 94, 94, 0, 0, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 0, 94, 94, 0, 0, 94, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 139, 79, 0, 0, 0, 35, 0, 147, 147, 147, 147, 147, 147, 147, 147, 147, 0, 0, 0, 0, 0, 0, 39, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[102, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 102, 102, 0, 0, 102, 0, 102, 102, 102, 102, 102, 102, 102, 102, 102, 0, 0, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 0, 102, 102, 0, 0, 102, 0, 0, 0, 0],
      #[118, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118, 118, 0, 0, 118, 0, 118, 118, 187, 118, 118, 203, 195, 118, 118, 0, 0, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 0, 118, 118, 0, 0, 118, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[106, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106, 106, 0, 0, 106, 0, 106, 106, 106, 106, 106, 106, 106, 106, 106, 0, 0, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 0, 106, 106, 0, 0, 106, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 110, 110, 0, 0, 110, 0, 110, 110, 110, 110, 110, 110, 110, 110, 110, 0, 0, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 0, 110, 110, 0, 0, 110, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 114, 114, 0, 0, 114, 0, 114, 114, 114, 114, 114, 114, 114, 114, 114, 0, 0, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 0, 114, 114, 0, 0, 114, 0, 0, 0, 0],
      #[130, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 130, 130, 0, 0, 130, 0, 130, 130, 0, 130, 130, 0, 0, 215, 223, 0, 0, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 0, 130, 130, 0, 0, 130, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[122, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 122, 122, 0, 0, 122, 0, 122, 122, 187, 122, 122, 203, 195, 122, 122, 0, 0, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 0, 122, 122, 0, 0, 122, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[126, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 126, 126, 0, 0, 126, 0, 126, 126, 187, 126, 126, 203, 195, 126, 126, 0, 0, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 0, 126, 126, 0, 0, 126, 0, 0, 0, 0],
      #[142, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 142, 142, 0, 0, 142, 0, 142, 142, 0, 142, 142, 0, 0, 0, 0, 0, 0, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 0, 235, 243, 0, 0, 142, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[134, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 134, 134, 0, 0, 134, 0, 134, 134, 0, 134, 134, 0, 0, 215, 223, 0, 0, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 0, 134, 134, 0, 0, 134, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[138, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 138, 0, 0, 138, 0, 138, 138, 0, 138, 138, 0, 0, 215, 223, 0, 0, 138, 138, 138, 138, 138, 138, 138, 138, 138, 138, 0, 138, 138, 0, 0, 138, 0, 0, 0, 0],
      #[162, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 162, 162, 0, 0, 162, 0, 162, 162, 0, 162, 162, 0, 0, 0, 0, 0, 0, 255, 263, 162, 162, 162, 271, 279, 162, 162, 162, 0, 0, 0, 0, 0, 162, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[146, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 146, 146, 0, 0, 146, 0, 146, 146, 0, 146, 146, 0, 0, 0, 0, 0, 0, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 0, 235, 243, 0, 0, 146, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[150, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 150, 150, 0, 0, 150, 0, 150, 150, 0, 150, 150, 0, 0, 0, 0, 0, 0, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 0, 235, 243, 0, 0, 150, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[154, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 154, 154, 0, 0, 154, 0, 154, 154, 0, 154, 154, 0, 0, 0, 0, 0, 0, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 0, 235, 243, 0, 0, 154, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[158, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 158, 158, 0, 0, 158, 0, 158, 158, 0, 158, 158, 0, 0, 0, 0, 0, 0, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 0, 235, 243, 0, 0, 158, 0, 0, 0, 0],
      #[174, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 174, 174, 0, 0, 174, 0, 174, 174, 0, 174, 174, 0, 0, 0, 0, 0, 0, 0, 0, 174, 174, 291, 0, 0, 299, 174, 174, 0, 0, 0, 0, 0, 174, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[166, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 166, 166, 0, 0, 166, 0, 166, 166, 0, 166, 166, 0, 0, 0, 0, 0, 0, 255, 263, 166, 166, 166, 271, 279, 166, 166, 166, 0, 0, 0, 0, 0, 166, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 170, 170, 0, 0, 170, 0, 170, 170, 0, 170, 170, 0, 0, 0, 0, 0, 0, 255, 263, 170, 170, 170, 271, 279, 170, 170, 170, 0, 0, 0, 0, 0, 170, 0, 0, 0, 0],
      #[182, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 182, 182, 0, 0, 182, 0, 182, 311, 0, 182, 182, 0, 0, 0, 0, 0, 0, 0, 0, 182, 182, 0, 0, 0, 0, 182, 182, 0, 0, 0, 0, 0, 182, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[178, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 178, 178, 0, 0, 178, 0, 178, 178, 0, 178, 178, 0, 0, 0, 0, 0, 0, 0, 0, 178, 178, 291, 0, 0, 299, 178, 178, 0, 0, 0, 0, 0, 178, 0, 0, 0, 0],
      #[190, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 190, 190, 0, 0, 190, 0, 190, 0, 0, 323, 190, 0, 0, 0, 0, 0, 0, 0, 0, 190, 190, 0, 0, 0, 0, 190, 190, 0, 0, 0, 0, 0, 190, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[186, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 186, 186, 0, 0, 186, 0, 186, 311, 0, 186, 186, 0, 0, 0, 0, 0, 0, 0, 0, 186, 186, 0, 0, 0, 0, 186, 186, 0, 0, 0, 0, 0, 186, 0, 0, 0, 0],
      #[198, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 198, 198, 0, 0, 198, 0, 198, 0, 0, 0, 335, 0, 0, 0, 0, 0, 0, 0, 0, 198, 198, 0, 0, 0, 0, 198, 198, 0, 0, 0, 0, 0, 198, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[194, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 194, 194, 0, 0, 194, 0, 194, 0, 0, 323, 194, 0, 0, 0, 0, 0, 0, 0, 0, 194, 194, 0, 0, 0, 0, 194, 194, 0, 0, 0, 0, 0, 194, 0, 0, 0, 0],
      #[206, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 206, 206, 0, 0, 206, 0, 206, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 206, 206, 0, 0, 0, 0, 347, 206, 0, 0, 0, 0, 0, 206, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[202, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 202, 202, 0, 0, 202, 0, 202, 0, 0, 0, 335, 0, 0, 0, 0, 0, 0, 0, 0, 202, 202, 0, 0, 0, 0, 202, 202, 0, 0, 0, 0, 0, 202, 0, 0, 0, 0],
      #[214, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 214, 0, 0, 214, 0, 214, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 367, 0, 0, 0, 0, 0, 0, 359, 0, 0, 0, 0, 0, 214, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[210, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 210, 210, 0, 0, 210, 0, 210, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 210, 210, 0, 0, 0, 0, 347, 210, 0, 0, 0, 0, 0, 210, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 375, 0, 0, 0, 0, 0, 359, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[218, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218, 218, 0, 0, 218, 0, 218, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 222, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 226, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 395, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 50, 0, 50, 50, 0, 50, 50, 50, 50, 50, 50, 50, 50, 50, 0, 0, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 0, 50, 50, 0, 0, 50, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 403, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[98, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 98, 98, 0, 0, 98, 0, 98, 98, 98, 98, 98, 98, 98, 98, 98, 0, 0, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 0, 98, 98, 0, 0, 98, 0, 0, 0, 0],
      #[230, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 230, 0, 0, 0, 0, 230, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 419, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[550, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 550, 0, 550, 550, 550, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 139, 0, 0, 0, 0, 35, 0, 147, 147, 147, 147, 147, 147, 147, 147, 147, 0, 0, 0, 0, 0, 0, 39, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 423, 595, 163, 0, 0, 567, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[534, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 534, 0, 447, 534, 431, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 435, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[554, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 554, 0, 554, 554, 554, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 443, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[558, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 558, 0, 558, 558, 558, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 139, 0, 0, 0, 0, 35, 0, 147, 147, 147, 147, 147, 147, 147, 147, 147, 0, 0, 0, 0, 0, 0, 39, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 451, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[570, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 570, 0, 570, 570, 570, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[522, 0, 0, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 522, 0, 555, 522, 163, 0, 0, 567, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 438, 438, 0, 438, 438, 438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 438, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 430, 430, 0, 483, 430, 467, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 430, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 430, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 471, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 446, 446, 0, 446, 446, 446, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 446, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 446, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 479, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 450, 450, 0, 450, 450, 450, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 450, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 450, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 139, 0, 0, 0, 0, 35, 0, 147, 147, 147, 147, 147, 147, 147, 147, 147, 0, 0, 0, 0, 0, 0, 39, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 487, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 454, 454, 0, 454, 454, 454, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 454, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 454, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 518, 0, 0, 518, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 506, 0, 0, 506, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 503, 0, 0, 498, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 139, 0, 0, 0, 0, 35, 0, 147, 147, 147, 147, 147, 147, 147, 147, 147, 0, 0, 0, 0, 0, 0, 39, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 511, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 510, 0, 0, 510, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 502, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 519, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 458, 458, 0, 458, 458, 458, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 458, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 458, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 490, 0, 0, 490, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 531, 0, 0, 482, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 539, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 494, 0, 0, 494, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 486, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 547, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 462, 462, 0, 462, 462, 462, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 462, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 462, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 514, 0, 0, 514, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 139, 0, 0, 0, 0, 35, 0, 147, 147, 147, 147, 147, 147, 147, 147, 147, 0, 0, 0, 0, 0, 0, 39, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 555, 595, 163, 0, 0, 567, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 563, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 442, 442, 0, 442, 442, 442, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 442, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 442, 0, 0, 0, 0, 0],
      #[466, 0, 0, 0, 466, 466, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 466, 0, 466, 466, 466, 0, 0, 567, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[470, 0, 0, 0, 470, 470, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 470, 0, 470, 470, 470, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[530, 0, 0, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 530, 0, 555, 530, 163, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 434, 434, 0, 483, 434, 467, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 434, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 434, 0, 0, 0, 0, 0],
      #[538, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 538, 0, 447, 538, 431, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 591, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[542, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 542, 0, 542, 542, 542, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[562, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 562, 0, 562, 562, 562, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 603, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[566, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 566, 0, 566, 566, 566, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[526, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 526, 0, 0, 526, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 615, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[574, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 574, 0, 574, 574, 574, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[530, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 530, 0, 423, 530, 163, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 627, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 78, 0, 0, 78, 0, 78, 78, 78, 78, 78, 78, 78, 78, 78, 0, 0, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 0, 78, 78, 0, 0, 78, 0, 0, 0, 0],
      #[74, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 74, 74, 0, 0, 74, 0, 74, 74, 74, 74, 74, 74, 74, 74, 74, 0, 0, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 0, 74, 74, 0, 0, 74, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 643, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 58, 58, 0, 58, 58, 0, 58, 58, 58, 58, 58, 58, 58, 58, 58, 0, 0, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 0, 58, 58, 0, 0, 58, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 426, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 426, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 414, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 414, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 663, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 659, 0, 0, 0, 0],
      #[406, 0, 0, 0, 406, 406, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 406, 406, 0, 406, 406, 406, 0, 0, 406, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 671, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 418, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 418, 0, 0, 0, 0],
      #[410, 0, 0, 0, 410, 410, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 410, 410, 0, 410, 410, 410, 0, 0, 410, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[394, 0, 0, 0, 394, 394, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 394, 394, 0, 394, 394, 394, 0, 0, 394, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[402, 0, 0, 0, 402, 402, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 402, 402, 0, 402, 402, 402, 0, 0, 402, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0, 0, 0, 0, 0],
      #[398, 0, 0, 0, 398, 398, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 398, 398, 0, 398, 398, 398, 0, 0, 398, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 731, 0, 0, 691, 0, 0, 0, 0, 567, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 691, 0, 0, 0, 0, 567, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 691, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 386, 386, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 703, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 390, 390, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 378, 378, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 727, 719, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 691, 0, 0, 0, 0, 567, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 382, 382, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 370, 0, 0, 0, 0, 370, 0, 370, 370, 370, 370, 370, 370, 370, 370, 370, 0, 0, 0, 0, 0, 0, 370, 370, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 370, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 374, 0, 0, 0, 0, 374, 0, 374, 374, 374, 374, 374, 374, 374, 374, 374, 0, 0, 0, 0, 0, 0, 374, 374, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 374, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 362, 0, 0, 0, 0, 362, 0, 362, 362, 362, 362, 362, 362, 362, 362, 362, 0, 0, 0, 0, 0, 0, 362, 362, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 362, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 139, 0, 0, 0, 0, 35, 0, 147, 147, 147, 147, 147, 147, 147, 147, 147, 0, 0, 0, 0, 0, 0, 39, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 747, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 366, 0, 0, 0, 0, 366, 0, 366, 366, 366, 366, 366, 366, 366, 366, 366, 0, 0, 0, 0, 0, 0, 366, 366, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 366, 0, 0, 0, 0],
      #[346, 0, 0, 0, 346, 346, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 346, 346, 0, 346, 346, 346, 0, 0, 346, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[350, 0, 0, 0, 350, 350, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 350, 350, 0, 350, 350, 350, 0, 0, 350, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 755, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 139, 0, 0, 0, 0, 35, 0, 147, 147, 147, 147, 147, 147, 147, 147, 147, 0, 0, 0, 0, 0, 0, 39, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 139, 0, 0, 0, 0, 35, 0, 147, 147, 147, 147, 147, 147, 147, 147, 147, 0, 0, 0, 0, 0, 0, 39, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 763, 0, 0, 0, 0],
      #[342, 0, 0, 0, 342, 342, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 342, 342, 0, 342, 342, 342, 0, 0, 342, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 274, 274, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 274, 0, 0, 274, 0, 0, 0, 0, 274, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 278, 278, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 278, 0, 0, 278, 0, 0, 0, 0, 278, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 270, 270, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 270, 0, 0, 270, 0, 0, 0, 0, 270, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 787, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 691, 0, 0, 0, 0, 567, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 290, 290, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 290, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 306, 306, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 306, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 795, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 691, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 310, 310, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 310, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 298, 298, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 298, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 807, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 819, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 787, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 691, 0, 0, 0, 0, 567, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 294, 294, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 294, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 302, 302, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 302, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 823, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 823, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 0, 0, 0, 0],
      #[0, 0, 0, 0, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 823, 242, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 246, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 843, 0, 0, 0, 0],
      #[0, 0, 0, 0, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 851, 0, 0, 0, 0],
      #[258, 0, 258, 258, 0, 258, 0, 0, 0, 0, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 0, 0, 0, 0, 258, 258, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 318, 0, 0, 0, 0, 318, 318, 318, 318, 318, 318, 318, 318, 318, 318, 318, 0, 318, 0, 0, 0, 0, 318, 318, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 691, 0, 0, 0, 0, 567, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 282, 282, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 875, 867, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 691, 0, 0, 0, 0, 567, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 286, 286, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[262, 0, 262, 262, 0, 262, 0, 0, 0, 0, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 0, 0, 0, 0, 262, 262, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 787, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 883, 0, 0, 691, 0, 0, 0, 0, 567, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[250, 0, 250, 250, 0, 250, 0, 0, 0, 0, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 0, 0, 0, 0, 250, 250, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 903, 807, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 891, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 823, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 899, 0, 0, 0, 0],
      #[254, 0, 254, 254, 0, 254, 0, 0, 0, 0, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 0, 0, 0, 0, 254, 254, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[266, 0, 266, 266, 0, 266, 0, 0, 0, 0, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 0, 0, 0, 0, 266, 266, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[586, 0, 586, 586, 0, 586, 0, 0, 0, 0, 586, 586, 586, 586, 586, 586, 586, 586, 586, 586, 586, 586, 586, 0, 0, 0, 0, 586, 586, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[34, 0, 34, 34, 0, 34, 0, 0, 0, 0, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 0, 0, 0, 0, 34, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[923, 0, 11, 15, 0, 139, 0, 0, 0, 0, 35, 23, 147, 147, 147, 147, 147, 147, 147, 147, 147, 19, 855, 0, 0, 0, 0, 39, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[38, 0, 38, 38, 0, 38, 0, 0, 0, 0, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 0, 0, 0, 0, 38, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 139, 0, 0, 0, 0, 35, 0, 147, 147, 147, 147, 147, 147, 147, 147, 147, 0, 0, 0, 0, 0, 0, 39, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[935, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[943, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 139, 79, 0, 0, 0, 35, 0, 147, 147, 147, 147, 147, 147, 147, 147, 147, 0, 0, 0, 0, 0, 0, 39, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[955, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[963, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 63, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 175, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 115, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87],
      #[975, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];

define method production-1
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <SIMPLE-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file -> EOF
  values(244,
         begin
           rhs-1;
         end);
end method production-1;

define method production-2
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <SIMPLE-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file -> file1 EOF
  values(244,
         begin
           rhs-1;
         end);
end method production-2;

define method production-3
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <SIMPLE-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file -> <ALIEN-NAME-TOKEN> type-name EOF
  values(244,
         begin
           rhs-2;
         end);
end method production-3;

define method production-4
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <SIMPLE-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file -> <ALIEN-NAME-TOKEN> identifier EOF
  values(244,
         begin
           element(srcloc-0.objects, rhs-2.string-value, default: #f)
             | parse-error(rhs-2, "Unknown identifier: %s", rhs-2.string-value);
         end);
end method production-4;

define method production-5
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <SIMPLE-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file -> <MACRO-PARSE-TOKEN> type-name EOF
  values(244,
         begin
           rhs-2;
         end);
end method production-5;

define method production-6
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <SIMPLE-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file -> <MACRO-PARSE-TOKEN> constant-expr EOF
  values(244,
         begin
           if (instance?(rhs-2, <identifier-token>))
             element(srcloc-0.objects, rhs-2.string-value, default: #f)
               | parse-error(rhs-2, "Unknown identifier: %s", rhs-2.string-value);
           else
             rhs-2;
           end if;
         end);
end method production-6;

define method production-7
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <SIMPLE-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file -> <CPP-PARSE-TOKEN> constant-expr EOF
  values(244,
         begin
           int-value(rhs-2, srcloc-0);
         end);
end method production-7;

define method production-8
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file1 -> external-definition
  values(228,
         begin
           rhs-1;
         end);
end method production-8;

define method production-9
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file1 -> file1 external-definition
  values(228,
         begin
           rhs-1;
         end);
end method production-9;

define method production-10
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // primary-expr -> identifier
  values(20,
         begin
           // We allow arbitrary identifiers only because they are occasionally
           // permitted by CPP (and treated as integers).  This will also allow a
           // single identifier to pass as a constant expr.  Users of "constant-expr"
           // should be aware of this and call "int-value" to insure that it is in fact
           // a constant value.  "parse-macro" takes advantage of this property of
           // "constant-expr" to allow defined identifiers to be parsed.
           rhs-1;
         end);
end method production-10;

define method production-11
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <LITERAL-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // primary-expr -> <INTEGER-TOKEN>
  values(20,
         begin
           rhs-1.value;
         end);
end method production-11;

define method production-12
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // primary-expr -> <LPAREN-TOKEN> expr <RPAREN-TOKEN>
  values(20,
         begin
           rhs-2;
         end);
end method production-12;

define method production-13
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // postfix-expr -> primary-expr
  values(25,
         begin
           rhs-1;
         end);
end method production-13;

define method production-14
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // postfix-expr -> postfix-expr <LPAREN-TOKEN> argument-expr-list <RPAREN-TOKEN>
  values(25,
         begin
           // There aren't any compile-time functions which we are prepared to
           // evaluate in general.  However, if we are evaluating an expression on a
           // CPP line, we should be prepared to evaluate the pseudo-function
           // "defined".
           //
           if (~instance?(srcloc-0, <parse-cpp-state>) | rhs-1.string-value ~= "defined")
             parse-error(srcloc-0,"Function calls not allowed in constant expressions.");
           elseif (element(rhs-3.generator.cpp-table, rhs-3.string-value, default: #f))
             1;
           else
             0;
           end if;
         end);
end method production-14;

define method production-15
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <NAME-TOKEN>, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // postfix-expr -> <MACHINE-TOKEN> <LPAREN-TOKEN> <IDENTIFIER-TOKEN> <RPAREN-TOKEN>
  values(25,
         begin
           // Handle the solaris "#machine(foo)" construct.  Simply return 0 -- machine
           // types should also be checked via the standard mechanism.
           0;
         end);
end method production-15;

define method production-16
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // argument-expr-list -> assignment-expr
  values(159,
         begin
           rhs-1;
         end);
end method production-16;

define method production-17
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // unary-expr -> postfix-expr
  values(42,
         begin
           rhs-1;
         end);
end method production-17;

define method production-18
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // unary-expr -> unary-operator cast-expr
  values(42,
         begin
           select (rhs-1 by instance?)
             <minus-token> => -int-value(rhs-2, srcloc-0);
             <tilde-token> => lognot(int-value(rhs-2, srcloc-0));
             <bang-token> => if (int-value(rhs-2, srcloc-0) == 0) 1 else 0 end if;
           end select;
         end);
end method production-18;

define method production-19
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // unary-expr -> <SIZEOF-TOKEN> <LPAREN-TOKEN> type-name <RPAREN-TOKEN>
  values(42,
         begin
           c-type-size(rhs-3);
         end);
end method production-19;

define method production-20
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // unary-operator -> <MINUS-TOKEN>
  values(30,
         begin
           rhs-1;
         end);
end method production-20;

define method production-21
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // unary-operator -> <TILDE-TOKEN>
  values(30,
         begin
           rhs-1;
         end);
end method production-21;

define method production-22
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // unary-operator -> <BANG-TOKEN>
  values(30,
         begin
           rhs-1;
         end);
end method production-22;

define method production-23
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // cast-expr -> unary-expr
  values(select (prev-state)
           100 => 101;
           50 => 51;
           48 => 49;
           46 => 47;
           30 => 157;
           OTHERWISE => 44;
         end,
         begin
           rhs-1;
         end);
end method production-23;

define method production-24
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>,
     rhs-4, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // cast-expr -> <LPAREN-TOKEN> type-name <RPAREN-TOKEN> cast-expr
  values(select (prev-state)
           100 => 101;
           50 => 51;
           48 => 49;
           46 => 47;
           30 => 157;
           OTHERWISE => 44;
         end,
         begin
           let result = int-value(rhs-4, srcloc-0);
           if (instance?(result, <integer>)
                & instance?(rhs-2.true-type, <integer-type-declaration>))
             result;
           else
             parse-error
               (srcloc-0,
                "Melange only handles compile time casts from integer to integer");
           end if;
         end);
end method production-24;

define method production-25
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // multiplicative-expr -> cast-expr
  values(select (prev-state)
           55 => 56;
           53 => 54;
           OTHERWISE => 45;
         end,
         begin
           rhs-1;
         end);
end method production-25;

define method production-26
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // multiplicative-expr -> multiplicative-expr <STAR-TOKEN> cast-expr
  values(select (prev-state)
           55 => 56;
           53 => 54;
           OTHERWISE => 45;
         end,
         begin
           int-value(rhs-1, srcloc-0) * int-value(rhs-3, srcloc-0);
         end);
end method production-26;

define method production-27
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // multiplicative-expr -> multiplicative-expr <SLASH-TOKEN> cast-expr
  values(select (prev-state)
           55 => 56;
           53 => 54;
           OTHERWISE => 45;
         end,
         begin
           truncate/(int-value(rhs-1, srcloc-0), int-value(rhs-3, srcloc-0));
         end);
end method production-27;

define method production-28
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // multiplicative-expr -> multiplicative-expr <PERCENT-TOKEN> cast-expr
  values(select (prev-state)
           55 => 56;
           53 => 54;
           OTHERWISE => 45;
         end,
         begin
           remainder(int-value(rhs-1, srcloc-0), int-value(rhs-3, srcloc-0));
         end);
end method production-28;

define method production-29
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // additive-expr -> multiplicative-expr
  values(select (prev-state)
           60 => 61;
           58 => 59;
           OTHERWISE => 52;
         end,
         begin
           rhs-1;
         end);
end method production-29;

define method production-30
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // additive-expr -> additive-expr <PLUS-TOKEN> multiplicative-expr
  values(select (prev-state)
           60 => 61;
           58 => 59;
           OTHERWISE => 52;
         end,
         begin
           int-value(rhs-1, srcloc-0) + int-value(rhs-3, srcloc-0);
         end);
end method production-30;

define method production-31
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // additive-expr -> additive-expr <MINUS-TOKEN> multiplicative-expr
  values(select (prev-state)
           60 => 61;
           58 => 59;
           OTHERWISE => 52;
         end,
         begin
           int-value(rhs-1, srcloc-0) - int-value(rhs-3, srcloc-0);
         end);
end method production-31;

define method production-32
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // shift-expr -> additive-expr
  values(select (prev-state)
           69 => 70;
           67 => 68;
           65 => 66;
           63 => 64;
           OTHERWISE => 57;
         end,
         begin
           rhs-1;
         end);
end method production-32;

define method production-33
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // shift-expr -> shift-expr <LEFT-OP-TOKEN> additive-expr
  values(select (prev-state)
           69 => 70;
           67 => 68;
           65 => 66;
           63 => 64;
           OTHERWISE => 57;
         end,
         begin
           ash(int-value(rhs-1, srcloc-0), int-value(rhs-3, srcloc-0))
         end);
end method production-33;

define method production-34
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // shift-expr -> shift-expr <RIGHT-OP-TOKEN> additive-expr
  values(select (prev-state)
           69 => 70;
           67 => 68;
           65 => 66;
           63 => 64;
           OTHERWISE => 57;
         end,
         begin
           ash(int-value(rhs-1, srcloc-0), -int-value(rhs-3, srcloc-0))
         end);
end method production-34;

define method production-35
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // relational-expr -> shift-expr
  values(select (prev-state)
           74 => 75;
           72 => 73;
           OTHERWISE => 62;
         end,
         begin
           rhs-1;
         end);
end method production-35;

define method production-36
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // relational-expr -> relational-expr <LT-TOKEN> shift-expr
  values(select (prev-state)
           74 => 75;
           72 => 73;
           OTHERWISE => 62;
         end,
         begin
           if (int-value(rhs-1, srcloc-0) < int-value(rhs-3, srcloc-0)) 1 else 0 end if;
         end);
end method production-36;

define method production-37
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // relational-expr -> relational-expr <GT-TOKEN> shift-expr
  values(select (prev-state)
           74 => 75;
           72 => 73;
           OTHERWISE => 62;
         end,
         begin
           if (int-value(rhs-1, srcloc-0) > int-value(rhs-3, srcloc-0)) 1 else 0 end if;
         end);
end method production-37;

define method production-38
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // relational-expr -> relational-expr <LE-OP-TOKEN> shift-expr
  values(select (prev-state)
           74 => 75;
           72 => 73;
           OTHERWISE => 62;
         end,
         begin
           if (int-value(rhs-1, srcloc-0) <= int-value(rhs-3, srcloc-0)) 1 else 0 end if;
         end);
end method production-38;

define method production-39
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // relational-expr -> relational-expr <GE-OP-TOKEN> shift-expr
  values(select (prev-state)
           74 => 75;
           72 => 73;
           OTHERWISE => 62;
         end,
         begin
           if (int-value(rhs-1, srcloc-0) >= int-value(rhs-3, srcloc-0)) 1 else 0 end if;
         end);
end method production-39;

define method production-40
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // equality-expr -> relational-expr
  values(select (prev-state)
           77 => 78;
           OTHERWISE => 71;
         end,
         begin
           rhs-1;
         end);
end method production-40;

define method production-41
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // equality-expr -> equality-expr <EQ-OP-TOKEN> relational-expr
  values(select (prev-state)
           77 => 78;
           OTHERWISE => 71;
         end,
         begin
           if (int-value(rhs-1, srcloc-0) == int-value(rhs-3, srcloc-0)) 1 else 0 end if;
         end);
end method production-41;

define method production-42
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // equality-expr -> equality-expr <NE-OP-TOKEN> relational-expr
  values(select (prev-state)
           77 => 78;
           OTHERWISE => 71;
         end,
         begin
           if (int-value(rhs-1, srcloc-0) ~= int-value(rhs-3, srcloc-0)) 1 else 0 end if;
         end);
end method production-42;

define method production-43
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // and-expr -> equality-expr
  values(select (prev-state)
           80 => 81;
           OTHERWISE => 76;
         end,
         begin
           rhs-1;
         end);
end method production-43;

define method production-44
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // and-expr -> and-expr <AMPERSAND-TOKEN> equality-expr
  values(select (prev-state)
           80 => 81;
           OTHERWISE => 76;
         end,
         begin
           logand(int-value(rhs-1, srcloc-0), int-value(rhs-3, srcloc-0))
         end);
end method production-44;

define method production-45
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // exclusive-or-expr -> and-expr
  values(select (prev-state)
           83 => 84;
           OTHERWISE => 79;
         end,
         begin
           rhs-1;
         end);
end method production-45;

define method production-46
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // exclusive-or-expr -> exclusive-or-expr <CARAT-TOKEN> and-expr
  values(select (prev-state)
           83 => 84;
           OTHERWISE => 79;
         end,
         begin
           logxor(int-value(rhs-1, srcloc-0), int-value(rhs-3, srcloc-0));
         end);
end method production-46;

define method production-47
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // inclusive-or-expr -> exclusive-or-expr
  values(select (prev-state)
           86 => 87;
           OTHERWISE => 82;
         end,
         begin
           rhs-1;
         end);
end method production-47;

define method production-48
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // inclusive-or-expr -> inclusive-or-expr <BAR-TOKEN> exclusive-or-expr
  values(select (prev-state)
           86 => 87;
           OTHERWISE => 82;
         end,
         begin
           logior(int-value(rhs-1, srcloc-0), int-value(rhs-3, srcloc-0));
         end);
end method production-48;

define method production-49
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // logical-and-expr -> inclusive-or-expr
  values(select (prev-state)
           89 => 90;
           OTHERWISE => 85;
         end,
         begin
           rhs-1;
         end);
end method production-49;

define method production-50
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // logical-and-expr -> logical-and-expr <AND-OP-TOKEN> inclusive-or-expr
  values(select (prev-state)
           89 => 90;
           OTHERWISE => 85;
         end,
         begin
           if (int-value(rhs-1, srcloc-0) == 0) rhs-1 else rhs-3 end if;
         end);
end method production-50;

define method production-51
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // logical-or-expr -> logical-and-expr
  values(select (prev-state)
           91 => 92;
           OTHERWISE => 88;
         end,
         begin
           rhs-1;
         end);
end method production-51;

define method production-52
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // logical-or-expr -> logical-or-expr <OR-OP-TOKEN> logical-and-expr
  values(select (prev-state)
           91 => 92;
           OTHERWISE => 88;
         end,
         begin
           if (int-value(rhs-1, srcloc-0) == 0) rhs-3 else rhs-1 end if;
         end);
end method production-52;

define method production-53
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // conditional-expr -> logical-or-expr
  values(select (prev-state)
           93 => 94;
           43 => 95;
           26 => 95;
           OTHERWISE => 102;
         end,
         begin
           rhs-1;
         end);
end method production-53;

define method production-54
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>,
     rhs-5, srcloc-5 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // conditional-expr -> logical-or-expr <QUESTION-TOKEN> logical-or-expr <COLON-TOKEN> conditional-expr
  values(select (prev-state)
           93 => 94;
           43 => 95;
           26 => 95;
           OTHERWISE => 102;
         end,
         begin
           if (int-value(rhs-1, srcloc-0) == 0) rhs-5 else rhs-3 end if;
         end);
end method production-54;

define method production-55
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // assignment-expr -> conditional-expr
  values(select (prev-state)
           43 => 96;
           OTHERWISE => 158;
         end,
         begin
           rhs-1;
         end);
end method production-55;

define method production-56
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // expr -> assignment-expr
  values(97,
         begin
           rhs-1;
         end);
end method production-56;

define method production-57
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // constant-expr -> conditional-expr
  values(select (prev-state)
           241 => 242;
           236 => 239;
           175 => 176;
           116 => 118;
           107 => 109;
           40 => 103;
           OTHERWISE => 161;
         end,
         begin
           // In general, constant expr will return an integer value.  However, for
           // obscure reasons, we also allow it to return a single identifier.
           rhs-1;
         end);
end method production-57;

define method production-58
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // lcurly-element -> <LCURLY-TOKEN> curly-list <RCURLY-TOKEN>
  values(207,
         begin
           #f;
         end);
end method production-58;

define method production-59
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // lcurly-element -> NON-CURLY
  values(207,
         begin
           #f;
         end);
end method production-59;

define method production-60
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // curly-list -> lcurly-element
  values(select (prev-state)
           222 => 223;
           207 => 208;
           205 => 209;
           OTHERWISE => 211;
         end,
         begin
           #f;
         end);
end method production-60;

define method production-61
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // curly-list -> lcurly-element curly-list
  values(select (prev-state)
           222 => 223;
           207 => 208;
           205 => 209;
           OTHERWISE => 211;
         end,
         begin
           #f;
         end);
end method production-61;

define method production-62
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declaration -> declaration-specifiers <SEMICOLON-TOKEN>
  values(226,
         begin
           *typedef-flag* := #f;
           process-type-list(rhs-1, srcloc-0);
         end);
end method production-62;

define method production-63
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>,
     rhs-4, srcloc-4 :: <source-location>,
     rhs-5 :: <PUNCTUATION-TOKEN>, srcloc-5 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declaration -> declaration-specifiers extended-declarator-list <LCURLY-TOKEN> curly-list <RCURLY-TOKEN>
  values(226,
         begin
           // Ignore inline declarations.  These occur in VC++ header files, so we'd
           // better be able to handle them.
           write-line(*standard-error*, "Warning: ignoring inline code declaration.");
           #f;
         end);
end method production-63;

define method production-64
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>,
     rhs-5, srcloc-5 :: <source-location>,
     rhs-6 :: <PUNCTUATION-TOKEN>, srcloc-6 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declaration -> <INLINE-TOKEN> declaration-specifiers extended-declarator-list <LCURLY-TOKEN> curly-list <RCURLY-TOKEN>
  values(226,
         begin
           // Ignore inline declarations.  These occur in VC++ header files, so we'd
           // better be able to handle them.
           #f;
         end);
end method production-64;

define method production-65
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declaration -> <EXTERN-TOKEN> init-declarator-list <SEMICOLON-TOKEN>
  values(226,
         begin
           // Storage class must be extern; unspecified type must be "int"
           let spec = list(make(<int-token>, generator: rhs-1.generator, string: "int"));
           let type = process-type-list(spec, srcloc-0);
           let names = reverse!(rhs-2);
           declare-objects(srcloc-0, type, names, *typedef-flag*);
           *typedef-flag* := #f;
         end);
end method production-65;

define method production-66
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declaration -> declaration-specifiers extended-declarator-list <SEMICOLON-TOKEN>
  values(226,
         begin
           let type = process-type-list(rhs-1, srcloc-0);
           let names = reverse!(rhs-2);
           declare-objects(srcloc-0, type, names, *typedef-flag*);
           *typedef-flag* := #f;
         end);
end method production-66;

define method production-67
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declaration-specifiers -> storage-class-specifier declaration-specifiers
  values(select (prev-state)
           7 => 193;
           4 => 194;
           OTHERWISE => 219;
         end,
         begin
           // Storage class must be extern -- no need to note it
           rhs-2;
         end);
end method production-67;

define method production-68
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declaration-specifiers -> type-specifier
  values(select (prev-state)
           7 => 193;
           4 => 194;
           OTHERWISE => 219;
         end,
         begin
           list(rhs-1);
         end);
end method production-68;

define method production-69
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declaration-specifiers -> numeric-specifier
  values(select (prev-state)
           7 => 193;
           4 => 194;
           OTHERWISE => 219;
         end,
         begin
           rhs-1;
         end);
end method production-69;

define method production-70
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // init-declarator-list -> declarator
  values(215,
         begin
           list(rhs-1);
         end);
end method production-70;

define method production-71
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // init-declarator-list -> init-declarator-list <COMMA-TOKEN> declarator
  values(215,
         begin
           pair(rhs-3, rhs-1);
         end);
end method production-71;

define method production-72
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // extended-declarator-list -> declarator
  values(select (prev-state)
           219 => 221;
           OTHERWISE => 200;
         end,
         begin
           // This hack is necessary because VC++ lets you redeclare typedefs.  Bad
           // idea!  Don't look for clean logic or robustness -- that would require
           // more work than MS deserves.
           list(rhs-1);
         end);
end method production-72;

define method production-73
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // extended-declarator-list -> extended-declarator-list <COMMA-TOKEN> declarator
  values(select (prev-state)
           219 => 221;
           OTHERWISE => 200;
         end,
         begin
           // see above.
           pair(rhs-3, rhs-1);
         end);
end method production-73;

define method production-74
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // extended-declarator-list -> extended-declarator
  values(select (prev-state)
           219 => 221;
           OTHERWISE => 200;
         end,
         begin
           list(rhs-1);
         end);
end method production-74;

define method production-75
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // extended-declarator-list -> extended-declarator-list <COMMA-TOKEN> extended-declarator
  values(select (prev-state)
           219 => 221;
           OTHERWISE => 200;
         end,
         begin
           // see above.
           pair(rhs-3, rhs-1);
         end);
end method production-75;

define method production-76
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <NAME-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // extended-declarator -> <TYPE-NAME-TOKEN>
  values(select (prev-state)
           201 => 203;
           OTHERWISE => 199;
         end,
         begin
           // see above.
           rhs-1;
         end);
end method production-76;

define method production-77
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <NAME-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // extended-declarator -> pointer <TYPE-NAME-TOKEN>
  values(select (prev-state)
           201 => 203;
           OTHERWISE => 199;
         end,
         begin
           // see above.
           pair(rhs-1, rhs-2);
         end);
end method production-77;

define method production-78
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // storage-class-specifier -> <TYPEDEF-TOKEN>
  values(7,
         begin
           *typedef-flag* := #t;
           rhs-1;
         end);
end method production-78;

define method production-79
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // storage-class-specifier -> <EXTERN-TOKEN>
  values(7,
         begin
           rhs-1;
         end);
end method production-79;

define method production-80
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <TYPE-SPECIFIER-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // numeric-specifier -> TYPE-SPEC
  values(select (prev-state)
           228 => 192;
           36 => 37;
           7 => 192;
           4 => 192;
           0 => 192;
           OTHERWISE => 38;
         end,
         begin
           list(rhs-1);
         end);
end method production-80;

define method production-81
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <TYPE-SPECIFIER-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // numeric-specifier -> TYPE-SPEC numeric-specifier
  values(select (prev-state)
           228 => 192;
           36 => 37;
           7 => 192;
           4 => 192;
           0 => 192;
           OTHERWISE => 38;
         end,
         begin
           pair(rhs-1, rhs-2);
         end);
end method production-81;

define method production-82
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // type-specifier -> struct-or-union-specifier
  values(select (prev-state)
           228 => 191;
           7 => 191;
           4 => 191;
           0 => 191;
           OTHERWISE => 35;
         end,
         begin
           rhs-1;
         end);
end method production-82;

define method production-83
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // type-specifier -> enum-specifier
  values(select (prev-state)
           228 => 191;
           7 => 191;
           4 => 191;
           0 => 191;
           OTHERWISE => 35;
         end,
         begin
           rhs-1;
         end);
end method production-83;

define method production-84
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <NAME-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // type-specifier -> <TYPE-NAME-TOKEN>
  values(select (prev-state)
           228 => 191;
           7 => 191;
           4 => 191;
           0 => 191;
           OTHERWISE => 35;
         end,
         begin
           srcloc-0.objects[rhs-1.value];
         end);
end method production-84;

define method production-85
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <NAME-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>,
     rhs-4, srcloc-4 :: <source-location>,
     rhs-5 :: <PUNCTUATION-TOKEN>, srcloc-5 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-or-union-specifier -> struct-or-union NAME <LCURLY-TOKEN> struct-declaration-list <RCURLY-TOKEN>
  values(12,
         begin
           make-struct-type(rhs-2.value, rhs-4, rhs-1, srcloc-0);
         end);
end method production-85;

define method production-86
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-or-union-specifier -> struct-or-union <LCURLY-TOKEN> struct-declaration-list <RCURLY-TOKEN>
  values(12,
         begin
           make-struct-type(#f, rhs-3, rhs-1, srcloc-0);
         end);
end method production-86;

define method production-87
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <NAME-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-or-union-specifier -> struct-or-union NAME
  values(12,
         begin
           make-struct-type(rhs-2.value, #f, rhs-1, srcloc-0);
         end);
end method production-87;

define method production-88
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-or-union -> <STRUCT-TOKEN>
  values(10,
         begin
           rhs-1;
         end);
end method production-88;

define method production-89
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-or-union -> <UNION-TOKEN>
  values(10,
         begin
           rhs-1;
         end);
end method production-89;

define method production-90
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-declaration-list -> struct-declaration
  values(select (prev-state)
           188 => 189;
           OTHERWISE => 184;
         end,
         begin
           rhs-1;
         end);
end method production-90;

define method production-91
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-declaration-list -> struct-declaration-list struct-declaration
  values(select (prev-state)
           188 => 189;
           OTHERWISE => 184;
         end,
         begin
           // Creates list in normal order.
           concatenate(rhs-1, rhs-2);
         end);
end method production-91;

define method production-92
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-declaration -> type-specifier-list struct-declarator-list <SEMICOLON-TOKEN>
  values(select (prev-state)
           189 => 185;
           184 => 185;
           OTHERWISE => 183;
         end,
         begin
           let type = process-type-list(reverse!(rhs-1), srcloc-0);
           let return = #();
           for (declarator in rhs-2)
             let (type, name) = process-declarator(type, declarator, srcloc-0);
             return := pair(pair(name.value, type), return);
           end for;
           return;
         end);
end method production-92;

define method production-93
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-declaration -> type-specifier-list <SEMICOLON-TOKEN>
  values(select (prev-state)
           189 => 185;
           184 => 185;
           OTHERWISE => 183;
         end,
         begin
           let type = process-type-list(reverse!(rhs-1), srcloc-0);
           list(pair("_anon_field", type));
         end);
end method production-93;

define method production-94
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-declarator-list -> struct-declarator
  values(178,
         begin
           list(rhs-1);
         end);
end method production-94;

define method production-95
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-declarator-list -> struct-declarator-list <COMMA-TOKEN> struct-declarator
  values(178,
         begin
           // Creates list in reverse order.
           pair(rhs-3, rhs-1);
         end);
end method production-95;

define method production-96
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-declarator -> declarator
  values(select (prev-state)
           179 => 180;
           OTHERWISE => 177;
         end,
         begin
           rhs-1;
         end);
end method production-96;

define method production-97
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-declarator -> declarator <COLON-TOKEN> constant-expr
  values(select (prev-state)
           179 => 180;
           OTHERWISE => 177;
         end,
         begin
           pair(#"bitfield", pair(int-value(rhs-3, srcloc-0), rhs-1));
         end);
end method production-97;

define method production-98
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // enum-specifier -> <ENUM-TOKEN> enum-elements
  values(33,
         begin
           make-struct-type(#f, rhs-2, rhs-1, srcloc-0);
         end);
end method production-98;

define method production-99
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <NAME-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // enum-specifier -> <ENUM-TOKEN> NAME enum-elements
  values(33,
         begin
           make-struct-type(rhs-2.value, rhs-3, rhs-1, srcloc-0);
         end);
end method production-99;

define method production-100
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <NAME-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // enum-specifier -> <ENUM-TOKEN> NAME
  values(33,
         begin
           make-struct-type(rhs-2.value, #f, rhs-1, srcloc-0);
         end);
end method production-100;

define method production-101
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // enum-elements -> <LCURLY-TOKEN> enumerator-list <RCURLY-TOKEN>
  values(select (prev-state)
           169 => 170;
           OTHERWISE => 168;
         end,
         begin
           reverse!(rhs-2);
         end);
end method production-101;

define method production-102
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // enum-elements -> <LCURLY-TOKEN> enumerator-list <COMMA-TOKEN> <RCURLY-TOKEN>
  values(select (prev-state)
           169 => 170;
           OTHERWISE => 168;
         end,
         begin
           reverse!(rhs-2);
         end);
end method production-102;

define method production-103
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // enumerator-list -> enumerator
  values(163,
         begin
           list(make-enum-slot(rhs-1.head, rhs-1.tail, #f, srcloc-0));
         end);
end method production-103;

define method production-104
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // enumerator-list -> enumerator-list <COMMA-TOKEN> enumerator
  values(163,
         begin
           // HACK: We depend here on the fact that this parser generator evaluates
           // the subtrees left-to-right.
           //
           // We do all of this on the fly because some (i.e. Apple's) C compilers
           // let later enum values be computed based upon those earlier in the 
           // same enum declaration.
           pair(make-enum-slot(rhs-3.head, rhs-3.tail, rhs-1.head, srcloc-0), rhs-1);
         end);
end method production-104;

define method production-105
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // enumerator -> identifier
  values(select (prev-state)
           165 => 166;
           OTHERWISE => 162;
         end,
         begin
           pair(rhs-1.value, #f);
         end);
end method production-105;

define method production-106
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // enumerator -> identifier <ASSIGN-TOKEN> constant-expr
  values(select (prev-state)
           165 => 166;
           OTHERWISE => 162;
         end,
         begin
           pair(rhs-1.value, int-value(rhs-3, srcloc-0));
         end);
end method production-106;

define method production-107
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declarator -> declarator2
  values(select (prev-state)
           219 => 195;
           216 => 217;
           213 => 214;
           201 => 202;
           194 => 195;
           179 => 174;
           171 => 174;
           113 => 137;
           OTHERWISE => 139;
         end,
         begin
           rhs-1;
         end);
end method production-107;

define method production-108
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declarator -> pointer declarator2
  values(select (prev-state)
           219 => 195;
           216 => 217;
           213 => 214;
           201 => 202;
           194 => 195;
           179 => 174;
           171 => 174;
           113 => 137;
           OTHERWISE => 139;
         end,
         begin
           pair(rhs-1, rhs-2);
         end);
end method production-108;

define method production-109
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declarator2 -> identifier
  values(select (prev-state)
           197 => 144;
           173 => 144;
           143 => 144;
           OTHERWISE => 115;
         end,
         begin
           rhs-1;
         end);
end method production-109;

define method production-110
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declarator2 -> <LPAREN-TOKEN> declarator <RPAREN-TOKEN>
  values(select (prev-state)
           197 => 144;
           173 => 144;
           143 => 144;
           OTHERWISE => 115;
         end,
         begin
           rhs-2
         end);
end method production-110;

define method production-111
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declarator2 -> declarator2 <LBRACKET-TOKEN> <RBRACKET-TOKEN>
  values(select (prev-state)
           197 => 144;
           173 => 144;
           143 => 144;
           OTHERWISE => 115;
         end,
         begin
           pair(#"vector", pair(#f, rhs-1));
         end);
end method production-111;

define method production-112
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declarator2 -> declarator2 <LBRACKET-TOKEN> constant-expr <RBRACKET-TOKEN>
  values(select (prev-state)
           197 => 144;
           173 => 144;
           143 => 144;
           OTHERWISE => 115;
         end,
         begin
           pair(#"vector", pair(int-value(rhs-3, srcloc-0), rhs-1));
         end);
end method production-112;

define method production-113
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declarator2 -> declarator2 <LPAREN-TOKEN> <RPAREN-TOKEN>
  values(select (prev-state)
           197 => 144;
           173 => 144;
           143 => 144;
           OTHERWISE => 115;
         end,
         begin
           pair(#"function", pair(list(make(<varargs-declaration>,
                                            name: "", type: unknown-type)), rhs-1));
         end);
end method production-113;

define method production-114
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declarator2 -> declarator2 <LPAREN-TOKEN> parameter-type-list <RPAREN-TOKEN>
  values(select (prev-state)
           197 => 144;
           173 => 144;
           143 => 144;
           OTHERWISE => 115;
         end,
         begin
           pair(#"function", pair(reverse!(rhs-3), rhs-1));
         end);
end method production-114;

define method production-115
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declarator2 -> declarator2 <LPAREN-TOKEN> parameter-identifier-list <RPAREN-TOKEN>
  values(select (prev-state)
           197 => 144;
           173 => 144;
           143 => 144;
           OTHERWISE => 115;
         end,
         begin
           pair(#"function", pair(reverse!(rhs-3), rhs-1));
         end);
end method production-115;

define method production-116
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // pointer -> <STAR-TOKEN>
  values(select (prev-state)
           219 => 197;
           201 => 197;
           194 => 197;
           141 => 142;
           138 => 143;
           113 => 143;
           105 => 154;
           39 => 154;
           OTHERWISE => 173;
         end,
         begin
           list(#"pointer");
         end);
end method production-116;

define method production-117
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // pointer -> <STAR-TOKEN> pointer
  values(select (prev-state)
           219 => 197;
           201 => 197;
           194 => 197;
           141 => 142;
           138 => 143;
           113 => 143;
           105 => 154;
           39 => 154;
           OTHERWISE => 173;
         end,
         begin
           pair(#"pointer", rhs-2);
         end);
end method production-117;

define method production-118
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // type-specifier-list -> type-specifier
  values(select (prev-state)
           236 => 39;
           231 => 39;
           189 => 171;
           188 => 171;
           184 => 171;
           43 => 39;
           32 => 39;
           11 => 171;
           OTHERWISE => 113;
         end,
         begin
           list(rhs-1);
         end);
end method production-118;

define method production-119
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // type-specifier-list -> numeric-specifier
  values(select (prev-state)
           236 => 39;
           231 => 39;
           189 => 171;
           188 => 171;
           184 => 171;
           43 => 39;
           32 => 39;
           11 => 171;
           OTHERWISE => 113;
         end,
         begin
           reverse!(rhs-1);
         end);
end method production-119;

define method production-120
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // parameter-identifier-list -> identifier-list
  values(135,
         begin
           rhs-1;
         end);
end method production-120;

define method production-121
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // parameter-identifier-list -> identifier-list <COMMA-TOKEN> <ELIPSIS-TOKEN>
  values(135,
         begin
           pair(make(<varargs-declaration>, name: "", type: unknown-type), rhs-1);
         end);
end method production-121;

define method production-122
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // identifier-list -> identifier
  values(131,
         begin
           list(make(<arg-declaration>, name: rhs-1.string-value, type: unknown-type));
         end);
end method production-122;

define method production-123
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // identifier-list -> identifier-list <COMMA-TOKEN> identifier
  values(131,
         begin
           // Produces list in reverse order.
           pair(make(<arg-declaration>, name: rhs-3.string-value, type: unknown-type),
                rhs-1);
         end);
end method production-123;

define method production-124
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // parameter-type-list -> parameter-list
  values(select (prev-state)
           120 => 128;
           111 => 152;
           OTHERWISE => 149;
         end,
         begin
           rhs-1;
         end);
end method production-124;

define method production-125
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // parameter-type-list -> parameter-list <COMMA-TOKEN> <ELIPSIS-TOKEN>
  values(select (prev-state)
           120 => 128;
           111 => 152;
           OTHERWISE => 149;
         end,
         begin
           pair(make(<varargs-declaration>, name: "", type: unknown-type), rhs-1);
         end);
end method production-125;

define method production-126
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // parameter-list -> parameter-declaration
  values(124,
         begin
           list(rhs-1);
         end);
end method production-126;

define method production-127
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // parameter-list -> parameter-list <COMMA-TOKEN> parameter-declaration
  values(124,
         begin
           // Produces lists in reverse order.
           pair(rhs-3, rhs-1);
         end);
end method production-127;

define method production-128
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // parameter-declaration -> type-specifier-list declarator
  values(select (prev-state)
           125 => 126;
           OTHERWISE => 123;
         end,
         begin
           let type = process-type-list(reverse!(rhs-1), srcloc-0);
           let (type, name) = process-declarator(type, rhs-2, srcloc-0);
           make(<arg-declaration>, name: name.string-value, type: type);
         end);
end method production-128;

define method production-129
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // parameter-declaration -> type-name
  values(select (prev-state)
           125 => 126;
           OTHERWISE => 123;
         end,
         begin
           make(<arg-declaration>, name: "", type: rhs-1);
         end);
end method production-129;

define method production-130
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // type-name -> type-specifier-list
  values(select (prev-state)
           236 => 237;
           231 => 232;
           43 => 99;
           32 => 155;
           OTHERWISE => 122;
         end,
         begin
           process-type-list(reverse!(rhs-1), srcloc-0);
         end);
end method production-130;

define method production-131
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // type-name -> type-specifier-list abstract-declarator
  values(select (prev-state)
           236 => 237;
           231 => 232;
           43 => 99;
           32 => 155;
           OTHERWISE => 122;
         end,
         begin
           let type = process-type-list(reverse!(rhs-1), srcloc-0);
           let (type, name) = process-declarator(type, rhs-2, srcloc-0);
           type;
         end);
end method production-131;

define method production-132
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator -> pointer
  values(select (prev-state)
           138 => 146;
           105 => 146;
           OTHERWISE => 151;
         end,
         begin
           list(rhs-1);
         end);
end method production-132;

define method production-133
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator -> abstract-declarator2
  values(select (prev-state)
           138 => 146;
           105 => 146;
           OTHERWISE => 151;
         end,
         begin
           rhs-1;
         end);
end method production-133;

define method production-134
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator -> pointer abstract-declarator2
  values(select (prev-state)
           138 => 146;
           105 => 146;
           OTHERWISE => 151;
         end,
         begin
           pair(rhs-1, rhs-2);
         end);
end method production-134;

define method production-135
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator2 -> <LPAREN-TOKEN> abstract-declarator <RPAREN-TOKEN>
  values(select (prev-state)
           154 => 145;
           143 => 145;
           OTHERWISE => 106;
         end,
         begin
           rhs-2;
         end);
end method production-135;

define method production-136
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator2 -> <LBRACKET-TOKEN> <RBRACKET-TOKEN>
  values(select (prev-state)
           154 => 145;
           143 => 145;
           OTHERWISE => 106;
         end,
         begin
           list(#"vector", #f);
         end);
end method production-136;

define method production-137
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator2 -> <LBRACKET-TOKEN> constant-expr <RBRACKET-TOKEN>
  values(select (prev-state)
           154 => 145;
           143 => 145;
           OTHERWISE => 106;
         end,
         begin
           list(#"vector", int-value(rhs-2, srcloc-0));
         end);
end method production-137;

define method production-138
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator2 -> abstract-declarator2 <LBRACKET-TOKEN> <RBRACKET-TOKEN>
  values(select (prev-state)
           154 => 145;
           143 => 145;
           OTHERWISE => 106;
         end,
         begin
           pair(#"vector", pair(#f, rhs-1));
         end);
end method production-138;

define method production-139
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator2 -> abstract-declarator2 <LBRACKET-TOKEN> constant-expr <RBRACKET-TOKEN>
  values(select (prev-state)
           154 => 145;
           143 => 145;
           OTHERWISE => 106;
         end,
         begin
           pair(#"vector", pair(int-value(rhs-3, srcloc-0), rhs-1));
         end);
end method production-139;

define method production-140
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator2 -> <LPAREN-TOKEN> <RPAREN-TOKEN>
  values(select (prev-state)
           154 => 145;
           143 => 145;
           OTHERWISE => 106;
         end,
         begin
           list(#"function",
                list(make(<varargs-declaration>, name: "", type: unknown-type)));
         end);
end method production-140;

define method production-141
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator2 -> <LPAREN-TOKEN> parameter-type-list <RPAREN-TOKEN>
  values(select (prev-state)
           154 => 145;
           143 => 145;
           OTHERWISE => 106;
         end,
         begin
           list(#"function", reverse!(rhs-2));
         end);
end method production-141;

define method production-142
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator2 -> abstract-declarator2 <LPAREN-TOKEN> <RPAREN-TOKEN>
  values(select (prev-state)
           154 => 145;
           143 => 145;
           OTHERWISE => 106;
         end,
         begin
           pair(#"function", pair(list(make(<varargs-declaration>,
                                            name: "", type: unknown-type)), rhs-1));
         end);
end method production-142;

define method production-143
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator2 -> abstract-declarator2 <LPAREN-TOKEN> parameter-type-list <RPAREN-TOKEN>
  values(select (prev-state)
           154 => 145;
           143 => 145;
           OTHERWISE => 106;
         end,
         begin
           pair(#"function", pair(reverse!(rhs-3), rhs-1));
         end);
end method production-143;

define method production-144
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <SIMPLE-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // external-definition -> <BEGIN-INCLUDE-TOKEN>
  values(select (prev-state)
           228 => 229;
           OTHERWISE => 227;
         end,
         begin
           if (srcloc-0.verbose)
             write-element(*standard-error*, '[');
             force-output(*standard-error*);
           end if;
           push-include-level(srcloc-0, rhs-1.string-value);
         end);
end method production-144;

define method production-145
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <EI-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // external-definition -> <END-INCLUDE-TOKEN>
  values(select (prev-state)
           228 => 229;
           OTHERWISE => 227;
         end,
         begin
           if (srcloc-0.verbose)
             write-element(*standard-error*, ']');
             force-output(*standard-error*);
           end if;
           do(curry(add-cpp-declaration, srcloc-0), rhs-1.value);
           pop-include-level(srcloc-0);
         end);
end method production-145;

define method production-146
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // external-definition -> declaration
  values(select (prev-state)
           228 => 229;
           OTHERWISE => 227;
         end,
         begin
           if (srcloc-0.verbose)
             write-element(*standard-error*, '.');
             force-output(*standard-error*);
           end if;
           rhs-1;
         end);
end method production-146;

define method production-147
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <NAME-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // identifier -> <IDENTIFIER-TOKEN>
  values(#[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 18, 0, 0, 18, 0, 18, 0, 18, 0, 0, 18, 0, 18, 0, 0, 18, 0, 18, 0, 0, 18, 0, 18, 0, 18, 0, 18, 0, 0, 18, 0, 18, 0, 0, 18, 0, 0, 18, 0, 0, 18, 0, 0, 18, 0, 0, 18, 0, 18, 0, 18, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 114, 0, 0, 18, 0, 0, 0, 130, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133, 0, 0, 0, 0, 0, 114, 0, 0, 0, 0, 114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 114, 114, 114, 0, 18, 0, 0, 0, 114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 114, 0, 0, 114, 0, 0, 0, 114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 114, 0, 0, 114, 0, 0, 114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 234, 0, 0, 0, 0, 18, 0, 0, 0, 0, 18][prev-state],
         begin
           rhs-1;
         end);
end method production-147;

define constant $number-of-pops
  = #[0, 1, 2, 3, 3, 3, 3, 3, 1, 2, 1, 1, 3, 1, 4, 4, 1, 1, 2, 4, 1, 1, 1, 1, 4, 1, 3, 3, 3, 1, 3, 3, 1, 3, 3, 1, 3, 3, 3, 3, 1, 3, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 5, 1, 1, 1, 3, 1, 1, 2, 2, 5, 6, 3, 3, 2, 1, 1, 1, 3, 1, 3, 1, 3, 1, 2, 1, 1, 1, 2, 1, 1, 1, 5, 4, 2, 1, 1, 1, 2, 3, 2, 1, 3, 1, 3, 2, 3, 2, 3, 4, 1, 3, 1, 3, 1, 2, 1, 3, 3, 4, 3, 4, 4, 1, 2, 1, 1, 1, 3, 1, 3, 1, 3, 1, 3, 2, 1, 1, 2, 1, 1, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 1, 1, 1, 1];

define constant $production-table :: <simple-object-vector>
  = vector(#f, production-1, production-2, production-3, production-4, production-5, production-6, production-7, production-8, production-9, production-10, production-11, production-12, production-13, production-14, production-15, production-16, production-17, production-18, production-19, production-20, production-21, production-22, production-23, production-24, production-25, production-26, production-27, production-28, production-29, production-30, production-31, production-32, production-33, production-34, production-35, production-36, production-37, production-38, production-39, production-40, production-41, production-42, production-43, production-44, production-45, production-46, production-47, production-48, production-49, production-50, production-51, production-52, production-53, production-54, production-55, production-56, production-57, production-58, production-59, production-60, production-61, production-62, production-63, production-64, production-65, production-66, production-67, production-68, production-69, production-70, production-71, production-72, production-73, production-74, production-75, production-76, production-77, production-78, production-79, production-80, production-81, production-82, production-83, production-84, production-85, production-86, production-87, production-88, production-89, production-90, production-91, production-92, production-93, production-94, production-95, production-96, production-97, production-98, production-99, production-100, production-101, production-102, production-103, production-104, production-105, production-106, production-107, production-108, production-109, production-110, production-111, production-112, production-113, production-114, production-115, production-116, production-117, production-118, production-119, production-120, production-121, production-122, production-123, production-124, production-125, production-126, production-127, production-128, production-129, production-130, production-131, production-132, production-133, production-134, production-135, production-136, production-137, production-138, production-139, production-140, production-141, production-142, production-143, production-144, production-145, production-146, production-147);

define constant $file-start-state = 0;


//----------------------------------------------------------------------
// More parser boilerplate
//----------------------------------------------------------------------

define method aux-get-token
    (parse-state :: <parse-state>) => (result :: <token>);
  get-token(parse-state.tokenizer);
end method aux-get-token;

define method aux-get-token
    (parse-state :: <parse-cpp-state>) => (result :: <token>);
  get-token(parse-state.tokenizer, cpp-line: #t, expand: #f);
end method aux-get-token;

// The initial size of the parser stacks.
// 
define constant $initial-stack-size = 200;

// grow -- internal.
//
// Grow a stack.  Make a new vector twice as long, copy the old elements
// across, and return it.
// 
define method grow (vec :: <simple-object-vector>)
    => new :: <simple-object-vector>;
  let old-size = vec.size;
  let new-size = old-size * 2;
  let new = make(<simple-object-vector>, size: new-size);
  for (index from 0 below old-size)
    new[index] := vec[index];
  end for;
  new;
end method grow;

define constant $eof-token = 0;

define method dformat (template :: <string>, #rest rest)
  apply(format, *standard-error*, template, rest);
end method;

// parse -- internal.
//
// The actual parser loop.  Drive the state machine and maintain the stacks
// until we hit an accept action or until be hit a bogus token.
// 
define method parse-loop
    (parse-state :: <parse-state>, #key debug :: <boolean> = #f)
    => result :: <object>;
  let start-state = $file-start-state;
  let tokenizer = parse-state.tokenizer;

  block (return)
    let state-stack = make(<simple-object-vector>, size: $initial-stack-size);
    let symbol-stack = make(<simple-object-vector>, size: $initial-stack-size);
    let srcloc-stack = make(<simple-object-vector>, size: $initial-stack-size);

    state-stack[0] := start-state;
    let top :: <integer> = 1;
    let (lookahead, lookahead-srcloc) = aux-get-token(parse-state);

    unless (lookahead.token-id == $eof-token)
      let actions :: <simple-object-vector> = $action-table[start-state];
      let action :: <integer> = actions[$eof-token];
    end unless;

    while (#t)
      let state :: <integer> = state-stack[top - 1];

      if (debug)
	dformat("top = %d, state = %d, lookahead = %s\n",
		top, state, lookahead);
      end if;

      let actions :: <simple-object-vector> = $action-table[state];
      let action :: <integer> = actions[lookahead.token-id];
      let (action-datum, action-kind)
	= truncate/(action, ash(1, $action-bits));
      select (action-kind)
	$error-action =>
	  parse-error(parse-state, "Parse error at or before %s",
                      lookahead.string-value);

	$accept-action =>
	  if (debug)
	    dformat("  accepting.\n");
	  end if;
	  unget-token(tokenizer, lookahead);
	  if (top ~== 2)
	    error("stack didn't get reduced all the way?");
	  end if;
	  return(symbol-stack[1]);

	$shift-action =>
	  if (top == state-stack.size)
	    state-stack := grow(state-stack);
	    symbol-stack := grow(symbol-stack);
	    srcloc-stack := grow(srcloc-stack);
	  end if;
	  if (debug)
	    dformat("  shifting to state %d.\n", action-datum);
	  end if;
	  state-stack[top] := action-datum;
	  symbol-stack[top] := lookahead;
	  srcloc-stack[top] := lookahead-srcloc;
	  top := top + 1;
	  let (new-lookahead, new-srcloc) = aux-get-token(parse-state);
	  lookahead := new-lookahead;
	  lookahead-srcloc := new-srcloc;

	  unless (lookahead.token-id == $eof-token)
	    let actions :: <simple-object-vector>
	      = $action-table[action-datum];
	    let action :: <integer> = actions[$eof-token];
	  end unless;

	$reduce-action =>
	  let semantic-action :: <function>
	    = $production-table[action-datum];
	  let number-pops :: <integer>
	    = $number-of-pops[action-datum];
	  if (debug)
	    dformat("  reducing by production %d, num pops = %d\n",
		    action-datum, number-pops);
	  end if;
	  let old-top = top - number-pops;
	  let extra-args = make(<simple-object-vector>, size: number-pops * 2);
	  for (index from 0 below number-pops)
	    extra-args[index * 2] := symbol-stack[old-top + index];
	    extra-args[index * 2 + 1] := srcloc-stack[old-top + index];
	  end for;
	  let new-srcloc = parse-state;
	  let (new-state :: <integer>, new-symbol)
	    = apply(semantic-action, state-stack[old-top - 1], new-srcloc,
		    extra-args);
	  if (old-top == state-stack.size)
	    state-stack := grow(state-stack);
	    symbol-stack := grow(symbol-stack);
	    srcloc-stack := grow(srcloc-stack);
	  end if;
	  state-stack[old-top] := new-state;
	  symbol-stack[old-top] := new-symbol;
	  srcloc-stack[old-top] := new-srcloc;
	  top := old-top + 1;

      end select;
    end while;
  end block;
end method parse-loop;

//----------------------------------------------------------------------
// External interfaces to the parsing engine.
//----------------------------------------------------------------------

// This function processes an entire include file, leaving a series of
// declarations in the returned parse state.
//
define method parse
    (files :: <sequence> /* of <string> */, #key defines, verbose)
 => (result :: <parse-state>);
  let stream = make(<byte-string-stream>, contents: "",
                    direction: #"input-output");
  for (file in files)
    format(stream, "#include \"%s\"\n", file);
  end for;
  stream.stream-position := #"start";
  let tokenizer = make(<tokenizer>, name: "<top-level>", defines: defines,
                       contents: stream.stream-contents);

  let parse-state = make(<parse-file-state>, tokenizer: tokenizer);
  parse-state.verbose := verbose;

  parse-loop(parse-state);
  if (tokenizer.cpp-decls)
    do(curry(add-cpp-declaration, parse-state), tokenizer.cpp-decls)
  end if;
  parse-state;
end;

// This function parses the contents of the given string and tries to
// interpret it as the name of an object or type declared in "old-state".
// Parse-type will signal an error if no such declaration is found.
//
define method parse-type
    (type :: <string>, old-state :: <parse-file-state>)
 => (result :: <declaration>);
  let tokenizer = make(<tokenizer>, name: concatenate("Type name: ", type),
		       typedefs-from: old-state.tokenizer, contents: type);
  unget-token(tokenizer, make(<alien-name-token>,
			      generator: tokenizer, string: ""));
  let parse-state
    = make(<parse-type-state>, tokenizer: tokenizer, parent: old-state);
  parse-loop(parse-state);
end;

// This function tries to evaluate a preprocessor constant in hopes that
// it will either evaluate to a type or object name or to a constant
// compile time value.  It returns the matched declaration or value, or it
// signals an error. 
//
define method parse-macro
    (name :: <string>, old-state :: <parse-state>)
 => (result :: <object>);
  let old-tokenizer = old-state.tokenizer;
  let tokenizer = make(<tokenizer>, name: concatenate("CPP Macro: ", name),
                       parent: old-tokenizer, contents: "");
  if (check-cpp-expansion(name, tokenizer))
    unget-token(tokenizer, make(<macro-parse-token>,
				generator: tokenizer, string: ""));
    let parse-state
      = make(<parse-macro-state>, tokenizer: tokenizer, parent: old-state);
    parse-loop(parse-state);
  else
    error("Macro not defined in 'parse-macro'.");
  end if;
end;

// This function evaluates a line of CPP input according to a limited set of C
// operators and an odd set of evaluation rules which make undefined
// identifiers into integers.  (Note that this function is used by the
// tokenizer, but also recursively uses the tokenizer by specifying a few
// magic keywords to avoid infinite recursion.)  This function consumes one
// line's worth of tokens from the tokenizer and then leaves it in a
// consistent state for further processing by a different parser.
//
define method cpp-parse (tokenizer :: <tokenizer>) => result :: <integer>;
  block ()
    let parse-state
      = make(<parse-cpp-state>, tokenizer: tokenizer);
    unget-token(tokenizer, make(<cpp-parse-token>,
				generator: tokenizer, string: ""));
    parse-loop(parse-state);
  cleanup 
    get-token(tokenizer); // un-unget the EOF, since we may want to
                          // continue with this tokenizer using a different
                          // lexer
  end block;
end;

